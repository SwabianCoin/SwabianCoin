<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>reference-Custom_Storage.rst</title>
<meta name="author" content="Arvid Norberg, arvid&#64;libtorrent.org" />
<meta name=viewport content="width=device-width, initial-scale=1">
<script type="text/javascript">
/* <![CDATA[ */
    (function() {
        var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'https://api.flattr.com/js/0.6/load.js?mode=auto';
        t.parentNode.insertBefore(s, t);
    })();
/* ]]> */
</script>
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" type="text/css" href="rst.css" />
<style type="text/css">
/* Hides from IE-mac \*/
* html pre { height: 1%; }
/* End hide from IE-mac */
</style>
</head>
<body>
<div class="document">
    <div id="container">
    <a href="index.html"><table id="header">
    <tr><td id="orange"></td>
    <td id="logo">libtorrent</td></tr>
    </table></a>
    <div id="main">

<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Arvid Norberg, <a class="last reference external" href="mailto:arvid&#64;libtorrent.org">arvid&#64;libtorrent.org</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.2.2</td></tr>
</tbody>
</table>
<p><a class="reference external" href="reference.html">home</a></p>
<div class="section" id="custom-storage">
<h1>Custom Storage</h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#custom-storage" id="id23">Custom Storage</a><ul>
<li><a class="reference internal" href="#storage-interface" id="id24">storage_interface</a></li>
<li><a class="reference internal" href="#default-storage" id="id25">default_storage</a></li>
<li><a class="reference internal" href="#file-pool" id="id26">file_pool</a></li>
</ul>
</li>
</ul>
</div>
<p>libtorrent provides a customization point for storage of data. By default,
(<tt class="docutils literal">default_storage</tt>) downloaded files are saved to disk according with the
general conventions of bittorrent clients, mimicking the original file layout
when the torrent was created. The libtorrent user may define a custom
storage to store piece data in a different way.</p>
<p>A custom storage implementation must derive from and implement the
<a class="reference external" href="reference-Custom_Storage.html#storage_interface">storage_interface</a>. You must also provide a function that constructs the
custom storage object and provide this function to the <a class="reference external" href="reference-Core.html#add_torrent()">add_torrent()</a> call
via <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a>. Either passed in to the constructor or by setting
the <a class="reference external" href="reference-Core.html#storage">add_torrent_params::storage</a> field.</p>
<p>This is an example storage implementation that stores all pieces in a
<tt class="docutils literal"><span class="pre">std::map</span></tt>, i.e. in RAM. It's not necessarily very useful in practice, but
illustrates the basics of implementing a custom storage.</p>
<pre class="code c++ literal-block">
<span class="keyword">struct</span> <span class="name label">temp_storage</span> <span class="punctuation">:</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_interface</span>
<span class="punctuation">{</span>
  <span class="keyword">explicit</span> <span class="name">temp_storage</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">file_storage</span> <span class="keyword">const</span><span class="operator">&amp;</span> <span class="name">fs</span><span class="punctuation">)</span> <span class="operator">:</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_interface</span><span class="punctuation">(</span><span class="name">fs</span><span class="punctuation">)</span> <span class="punctuation">{}</span>
  <span class="keyword type">void</span> <span class="name">initialize</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span> <span class="punctuation">{}</span>
  <span class="keyword type">bool</span> <span class="name">has_any_file</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span> <span class="punctuation">{</span> <span class="keyword">return</span> <span class="name builtin">false</span><span class="punctuation">;</span> <span class="punctuation">}</span>
  <span class="keyword type">void</span> <span class="name">set_file_priority</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">aux</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">download_priority_t</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">file_index_t</span><span class="operator">&gt;&amp;</span>
    <span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span> <span class="punctuation">{}</span>
  <span class="keyword type">int</span> <span class="name">readv</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">iovec_t</span> <span class="keyword">const</span><span class="operator">&gt;</span> <span class="name">bufs</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span> <span class="name">piece</span>
    <span class="punctuation">,</span> <span class="keyword type">int</span> <span class="name">offset</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">open_mode_t</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span>
  <span class="punctuation">{</span>
    <span class="keyword">auto</span> <span class="keyword">const</span> <span class="name">i</span> <span class="operator">=</span> <span class="name">m_file_data</span><span class="punctuation">.</span><span class="name">find</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">);</span>
    <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">i</span> <span class="operator">==</span> <span class="name">m_file_data</span><span class="punctuation">.</span><span class="name">end</span><span class="punctuation">())</span> <span class="keyword">return</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
    <span class="keyword">if</span> <span class="punctuation">(</span><span class="keyword type">int</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">())</span> <span class="operator">&lt;=</span> <span class="name">offset</span><span class="punctuation">)</span> <span class="keyword">return</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
    <span class="name">lt</span><span class="operator">::</span><span class="name">iovec_t</span> <span class="name">data</span><span class="punctuation">{</span> <span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">()</span> <span class="operator">+</span> <span class="name">offset</span><span class="punctuation">,</span> <span class="keyword type">int</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">()</span> <span class="operator">-</span> <span class="name">offset</span><span class="punctuation">)</span> <span class="punctuation">};</span>
    <span class="keyword type">int</span> <span class="name">ret</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
    <span class="keyword">for</span> <span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">iovec_t</span> <span class="keyword">const</span><span class="operator">&amp;</span> <span class="name label">b</span> <span class="punctuation">:</span> <span class="name">bufs</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      <span class="keyword type">int</span> <span class="keyword">const</span> <span class="name">to_copy</span> <span class="operator">=</span> <span class="name">std</span><span class="operator">::</span><span class="name">min</span><span class="punctuation">(</span><span class="keyword type">int</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">()),</span> <span class="keyword type">int</span><span class="punctuation">(</span><span class="name">data</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">()));</span>
      <span class="name">memcpy</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">(),</span> <span class="name">data</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">(),</span> <span class="name">to_copy</span><span class="punctuation">);</span>
      <span class="name">data</span> <span class="operator">=</span> <span class="name">data</span><span class="punctuation">.</span><span class="name">subspan</span><span class="punctuation">(</span><span class="name">to_copy</span><span class="punctuation">);</span>
      <span class="name">ret</span> <span class="operator">+=</span> <span class="name">to_copy</span><span class="punctuation">;</span>
      <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">data</span><span class="punctuation">.</span><span class="name">empty</span><span class="punctuation">())</span> <span class="keyword">break</span><span class="punctuation">;</span>
    <span class="punctuation">}</span>
    <span class="keyword">return</span> <span class="name">ret</span><span class="punctuation">;</span>
  <span class="punctuation">}</span>
  <span class="keyword type">int</span> <span class="name">writev</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">iovec_t</span> <span class="keyword">const</span><span class="operator">&gt;</span> <span class="name">bufs</span>
    <span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span> <span class="keyword">const</span> <span class="name">piece</span><span class="punctuation">,</span> <span class="keyword type">int</span> <span class="name">offset</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">open_mode_t</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span>
  <span class="punctuation">{</span>
    <span class="keyword">auto</span><span class="operator">&amp;</span> <span class="name">data</span> <span class="operator">=</span> <span class="name">m_file_data</span><span class="punctuation">[</span><span class="name">piece</span><span class="punctuation">];</span>
    <span class="keyword type">int</span> <span class="name">ret</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
    <span class="keyword">for</span> <span class="punctuation">(</span><span class="keyword">auto</span><span class="operator">&amp;</span> <span class="name label">b</span> <span class="punctuation">:</span> <span class="name">bufs</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      <span class="keyword">if</span> <span class="punctuation">(</span><span class="keyword type">int</span><span class="punctuation">(</span><span class="name">data</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">())</span> <span class="operator">&lt;</span> <span class="name">offset</span> <span class="operator">+</span> <span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">())</span> <span class="name">data</span><span class="punctuation">.</span><span class="name">resize</span><span class="punctuation">(</span><span class="name">offset</span> <span class="operator">+</span> <span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">());</span>
      <span class="name">std</span><span class="operator">::</span><span class="name">memcpy</span><span class="punctuation">(</span><span class="name">data</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">()</span> <span class="operator">+</span> <span class="name">offset</span><span class="punctuation">,</span> <span class="name">b</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">(),</span> <span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">());</span>
      <span class="name">offset</span> <span class="operator">+=</span> <span class="keyword type">int</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">());</span>
      <span class="name">ret</span> <span class="operator">+=</span> <span class="keyword type">int</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">());</span>
    <span class="punctuation">}</span>
    <span class="keyword">return</span> <span class="name">ret</span><span class="punctuation">;</span>
  <span class="punctuation">}</span>
  <span class="keyword type">void</span> <span class="name">rename_file</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">file_index_t</span><span class="punctuation">,</span> <span class="name">std</span><span class="operator">::</span><span class="name">string</span> <span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span>
  <span class="punctuation">{</span> <span class="name">assert</span><span class="punctuation">(</span><span class="name builtin">false</span><span class="punctuation">);</span> <span class="punctuation">}</span>
  <span class="name">lt</span><span class="operator">::</span><span class="name">status_t</span> <span class="name">move_storage</span><span class="punctuation">(</span><span class="name">std</span><span class="operator">::</span><span class="name">string</span> <span class="keyword">const</span><span class="operator">&amp;</span>
    <span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">move_flags_t</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span> <span class="punctuation">{</span> <span class="keyword">return</span> <span class="name">lt</span><span class="operator">::</span><span class="name">status_t</span><span class="operator">::</span><span class="name">no_error</span><span class="punctuation">;</span> <span class="punctuation">}</span>
  <span class="keyword type">bool</span> <span class="name">verify_resume_data</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">add_torrent_params</span> <span class="keyword">const</span><span class="operator">&amp;</span>
    <span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">aux</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">file_index_t</span><span class="operator">&gt;</span> <span class="keyword">const</span><span class="operator">&amp;</span>
    <span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span>
  <span class="punctuation">{</span> <span class="keyword">return</span> <span class="name builtin">false</span><span class="punctuation">;</span> <span class="punctuation">}</span>
  <span class="keyword type">void</span> <span class="name">release_files</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span> <span class="punctuation">{}</span>
  <span class="keyword type">void</span> <span class="name">delete_files</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">remove_flags_t</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="punctuation">)</span> <span class="keyword">override</span> <span class="punctuation">{}</span>

  <span class="name">std</span><span class="operator">::</span><span class="name">map</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="punctuation">,</span> <span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">&gt;&gt;</span> <span class="name">m_file_data</span><span class="punctuation">;</span>
<span class="punctuation">};</span>

<span class="name">lt</span><span class="operator">::</span><span class="name">storage_interface</span><span class="operator">*</span> <span class="name">temp_storage_constructor</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_params</span> <span class="keyword">const</span><span class="operator">&amp;</span> <span class="name">params</span><span class="punctuation">,</span> <span class="name">lt</span><span class="operator">::</span><span class="name">file_pool</span><span class="operator">&amp;</span><span class="punctuation">)</span>
<span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="name">temp_storage</span><span class="punctuation">(</span><span class="name">params</span><span class="punctuation">.</span><span class="name">files</span><span class="punctuation">);</span>
<span class="punctuation">}</span>
</pre>
<a name="storage_interface"></a><div class="section" id="storage-interface">
<h2>storage_interface</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/storage.hpp">libtorrent/storage.hpp</a>&quot;</p>
<p>The storage interface is a pure virtual class that can be implemented to
customize how and where data for a torrent is stored. The default storage
implementation uses regular files in the filesystem, mapping the files in
the torrent in the way one would assume a torrent is saved to disk.
Implementing your own storage interface makes it possible to store all
data in RAM, or in some optimized order on disk (the order the pieces are
received for instance), or saving multi file torrents in a single file in
order to be able to take advantage of optimized disk-I/O.</p>
<p>It is also possible to write a thin class that uses the default storage
but modifies some particular behavior, for instance encrypting the data
before it's written to disk, and decrypting it when it's read again.</p>
<p>The storage interface is based on pieces. Every read and write operation
happens in the piece-space. Each piece fits 'piece_size' number
of bytes. All access is done by writing and reading whole or partial
pieces.</p>
<p>libtorrent comes with two built-in storage implementations;
<tt class="docutils literal">default_storage</tt> and <tt class="docutils literal">disabled_storage</tt>. Their constructor functions
are called <a class="reference external" href="reference-Storage.html#default_storage_constructor()">default_storage_constructor()</a> and
<tt class="docutils literal">disabled_storage_constructor</tt> respectively. The disabled storage does
just what it sounds like. It throws away data that's written, and it
reads garbage. It's useful mostly for benchmarking and profiling purpose.</p>
<pre class="literal-block">
struct storage_interface: std::enable_shared_from_this&lt;storage_interface&gt;, aux::disk_job_fence, aux::storage_piece_set
{
   explicit <strong>storage_interface</strong> (file_storage const&amp; fs);
   storage_interface&amp; <strong>operator=</strong> (storage_interface const&amp;) = delete;
   <strong>storage_interface</strong> (storage_interface const&amp;) = delete;
   virtual void <strong>initialize</strong> (storage_error&amp; ec) = 0;
   virtual int <strong>writev</strong> (span&lt;iovec_t const&gt; bufs
      , piece_index_t piece, int offset, open_mode_t flags, storage_error&amp; ec) = 0;
   virtual int <strong>readv</strong> (span&lt;iovec_t const&gt; bufs
      , piece_index_t piece, int offset, open_mode_t flags, storage_error&amp; ec) = 0;
   virtual bool <strong>has_any_file</strong> (storage_error&amp; ec) = 0;
   virtual void <strong>set_file_priority</strong> (aux::vector&lt;download_priority_t, file_index_t&gt;&amp; prio
      , storage_error&amp; ec) = 0;
   virtual status_t <strong>move_storage</strong> (std::string const&amp; save_path
      , move_flags_t flags, storage_error&amp; ec) = 0;
   virtual bool <strong>verify_resume_data</strong> (add_torrent_params const&amp; rd
      , aux::vector&lt;std::string, file_index_t&gt; const&amp; links
      , storage_error&amp; ec) = 0;
   virtual void <strong>release_files</strong> (storage_error&amp; ec) = 0;
   virtual void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename
      , storage_error&amp; ec) = 0;
   virtual void <strong>delete_files</strong> (remove_flags_t options, storage_error&amp; ec) = 0;
   virtual bool <strong>tick</strong> ();
   file_storage const&amp; <strong>files</strong> () const;
   bool <strong>set_need_tick</strong> ();
   void <strong>do_tick</strong> ();
   void <strong>set_owner</strong> (std::shared_ptr&lt;void&gt; const&amp; tor);
   aux::session_settings const&amp; <strong>settings</strong> () const;
   storage_index_t <strong>storage_index</strong> () const;
   void <strong>set_storage_index</strong> (storage_index_t st);
   int <strong>dec_refcount</strong> ();
   void <strong>inc_refcount</strong> ();

   aux::session_settings const* m_settings = nullptr;
};
</pre>
<a name="initialize()"></a><div class="section" id="initialize">
<h3>initialize()</h3>
<pre class="literal-block">
virtual void <strong>initialize</strong> (storage_error&amp; ec) = 0;
</pre>
<p>This function is called when the <em>storage</em> on disk is to be
initialized. The default storage will create directories and empty
files at this point. If <tt class="docutils literal">allocate_files</tt> is true, it will also
<tt class="docutils literal">ftruncate</tt> all files to their target size.</p>
<p>This function may be called multiple time on a single instance. When a
torrent is force-rechecked, the storage is re-initialized to trigger
the re-check from scratch.</p>
<p>The function is not necessarily called before other member functions.
For instance has_any_files() and <a class="reference external" href="reference-Custom_Storage.html#verify_resume_data()">verify_resume_data()</a> are
called early to determine whether we may have to check all files or
not. If we're doing a full check of the files every piece will be
hashed, causing <a class="reference external" href="reference-Custom_Storage.html#readv()">readv()</a> to be called as well.</p>
<p>Any required internals that need initialization should be done in the
constructor. This function is called before the torrent starts to
download.</p>
<p>If an error occurs, <tt class="docutils literal">storage_error</tt> should be set to reflect it.</p>
<a name="writev()"></a>
<a name="readv()"></a></div>
<div class="section" id="writev-readv">
<h3>writev() readv()</h3>
<pre class="literal-block">
virtual int <strong>writev</strong> (span&lt;iovec_t const&gt; bufs
      , piece_index_t piece, int offset, open_mode_t flags, storage_error&amp; ec) = 0;
virtual int <strong>readv</strong> (span&lt;iovec_t const&gt; bufs
      , piece_index_t piece, int offset, open_mode_t flags, storage_error&amp; ec) = 0;
</pre>
<p>These functions should read and write the data in or to the given
<tt class="docutils literal">piece</tt> at the given <tt class="docutils literal">offset</tt>. It should read or write
<tt class="docutils literal">num_bufs</tt> buffers sequentially, where the size of each buffer is
specified in the buffer array <tt class="docutils literal">bufs</tt>. The iovec_t type has the
following members:</p>
<pre class="literal-block">
struct iovec_t { void* iov_base; size_t iov_len; };
</pre>
<p>These functions may be called simultaneously from multiple threads.
Make sure they are thread safe. The <tt class="docutils literal">file</tt> in libtorrent is thread
safe when it can fall back to <tt class="docutils literal">pread</tt>, <tt class="docutils literal">preadv</tt> or the windows
equivalents. On targets where read operations cannot be thread safe
(i.e one has to seek first and then read), only one disk thread is
used.</p>
<p>The <tt class="docutils literal">offset</tt> is aligned to 16 kiB boundaries  <em>most of the time</em>, but
there are rare exceptions when it's not. Specifically if the read
cache is disabled/or full and a peer requests unaligned data. Most
clients request aligned data.</p>
<p>The number of bytes read or written should be returned, or -1 on
error. If there's an error, the <tt class="docutils literal">storage_error</tt> must be filled out
to represent the error that occurred.</p>
<a name="has_any_file()"></a></div>
<div class="section" id="has-any-file">
<h3>has_any_file()</h3>
<pre class="literal-block">
virtual bool <strong>has_any_file</strong> (storage_error&amp; ec) = 0;
</pre>
<p>This function is called when first checking (or re-checking) the
storage for a torrent. It should return true if any of the files that
is used in this storage exists on disk. If so, the storage will be
checked for existing pieces before starting the download.</p>
<p>If an error occurs, <tt class="docutils literal">storage_error</tt> should be set to reflect it.</p>
<a name="set_file_priority()"></a></div>
<div class="section" id="set-file-priority">
<h3>set_file_priority()</h3>
<pre class="literal-block">
virtual void <strong>set_file_priority</strong> (aux::vector&lt;download_priority_t, file_index_t&gt;&amp; prio
      , storage_error&amp; ec) = 0;
</pre>
<p>change the priorities of files. This is a fenced job and is
guaranteed to be the only running function on this storage
when called</p>
<a name="move_storage()"></a></div>
<div class="section" id="move-storage">
<h3>move_storage()</h3>
<pre class="literal-block">
virtual status_t <strong>move_storage</strong> (std::string const&amp; save_path
      , move_flags_t flags, storage_error&amp; ec) = 0;
</pre>
<p>This function should move all the files belonging to the storage to
the new save_path. The default storage moves the single file or the
directory of the torrent.</p>
<p>Before moving the files, any open file handles may have to be closed,
like <tt class="docutils literal">release_files()</tt>.</p>
<p>If an error occurs, <tt class="docutils literal">storage_error</tt> should be set to reflect it.</p>
<a name="verify_resume_data()"></a></div>
<div class="section" id="verify-resume-data">
<h3>verify_resume_data()</h3>
<pre class="literal-block">
virtual bool <strong>verify_resume_data</strong> (add_torrent_params const&amp; rd
      , aux::vector&lt;std::string, file_index_t&gt; const&amp; links
      , storage_error&amp; ec) = 0;
</pre>
<p>This function should verify the resume data <tt class="docutils literal">rd</tt> with the files
on disk. If the resume data seems to be up-to-date, return true. If
not, set <tt class="docutils literal">error</tt> to a description of what mismatched and return false.</p>
<p>The default storage may compare file sizes and time stamps of the files.</p>
<p>If an error occurs, <tt class="docutils literal">storage_error</tt> should be set to reflect it.</p>
<p>This function should verify the resume data <tt class="docutils literal">rd</tt> with the files
on disk. If the resume data seems to be up-to-date, return true. If
not, set <tt class="docutils literal">error</tt> to a description of what mismatched and return false.</p>
<p>If the <tt class="docutils literal">links</tt> pointer is non-empty, it has the same number
of elements as there are files. Each element is either empty or contains
the absolute path to a file identical to the corresponding file in this
torrent. The storage must create hard links (or copy) those files. If
any file does not exist or is inaccessible, the disk job must fail.</p>
<a name="release_files()"></a></div>
<div class="section" id="release-files">
<h3>release_files()</h3>
<pre class="literal-block">
virtual void <strong>release_files</strong> (storage_error&amp; ec) = 0;
</pre>
<p>This function should release all the file handles that it keeps open
to files belonging to this storage. The default implementation just
calls file_pool::release_files().</p>
<p>If an error occurs, <tt class="docutils literal">storage_error</tt> should be set to reflect it.</p>
<a name="rename_file()"></a></div>
<div class="section" id="rename-file">
<h3>rename_file()</h3>
<pre class="literal-block">
virtual void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename
      , storage_error&amp; ec) = 0;
</pre>
<p>Rename the file with index <tt class="docutils literal">file</tt> to name <tt class="docutils literal">new_name</tt>.</p>
<p>If an error occurs, <tt class="docutils literal">storage_error</tt> should be set to reflect it.</p>
<a name="delete_files()"></a></div>
<div class="section" id="delete-files">
<h3>delete_files()</h3>
<pre class="literal-block">
virtual void <strong>delete_files</strong> (remove_flags_t options, storage_error&amp; ec) = 0;
</pre>
<p>This function should delete some or all of the storage for this torrent.
The <tt class="docutils literal">options</tt> parameter specifies whether to delete all files or just
the partfile. <tt class="docutils literal">options</tt> are set to the same value as the options
passed to session::remove_torrent().</p>
<p>If an error occurs, <tt class="docutils literal">storage_error</tt> should be set to reflect it.</p>
<p>The <tt class="docutils literal">disk_buffer_pool</tt> is used to allocate and free disk buffers. It
has the following members:</p>
<pre class="code c++ literal-block">
<span class="keyword">struct</span> <span class="name">disk_buffer_pool</span>
<span class="punctuation">{</span>
        <span class="keyword type">char</span><span class="operator">*</span> <span class="name">allocate_buffer</span><span class="punctuation">(</span><span class="keyword type">char</span> <span class="keyword">const</span><span class="operator">*</span> <span class="name">category</span><span class="punctuation">);</span>
        <span class="keyword type">void</span> <span class="name function">free_buffer</span><span class="punctuation">(</span><span class="keyword type">char</span><span class="operator">*</span> <span class="name">buf</span><span class="punctuation">);</span>

        <span class="keyword type">char</span><span class="operator">*</span> <span class="name function">allocate_buffers</span><span class="punctuation">(</span><span class="keyword type">int</span> <span class="name">blocks</span><span class="punctuation">,</span> <span class="keyword type">char</span> <span class="keyword">const</span><span class="operator">*</span> <span class="name">category</span><span class="punctuation">);</span>
        <span class="keyword type">void</span> <span class="name function">free_buffers</span><span class="punctuation">(</span><span class="keyword type">char</span><span class="operator">*</span> <span class="name">buf</span><span class="punctuation">,</span> <span class="keyword type">int</span> <span class="name">blocks</span><span class="punctuation">);</span>

        <span class="keyword type">int</span> <span class="name function">block_size</span><span class="punctuation">()</span> <span class="keyword">const</span> <span class="punctuation">{</span> <span class="keyword">return</span> <span class="name">m_block_size</span><span class="punctuation">;</span> <span class="punctuation">}</span>

<span class="punctuation">};</span>
</pre>
<a name="tick()"></a></div>
<div class="section" id="tick">
<h3>tick()</h3>
<pre class="literal-block">
virtual bool <strong>tick</strong> ();
</pre>
<p>called periodically (useful for deferred flushing). When returning
false, it means no more ticks are necessary. Any disk job submitted
will re-enable ticking. The default will always turn ticking back
off again.</p>
<a name="settings()"></a></div>
<div class="section" id="settings">
<h3>settings()</h3>
<pre class="literal-block">
aux::session_settings const&amp; <strong>settings</strong> () const;
</pre>
<p>access global session_settings</p>
<a name="m_settings"></a><dl class="docutils">
<dt>m_settings</dt>
<dd>initialized in disk_io_thread::perform_async_job</dd>
</dl>
<a name="default_storage"></a></div>
</div>
<div class="section" id="default-storage">
<h2>default_storage</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/storage.hpp">libtorrent/storage.hpp</a>&quot;</p>
<p>The default implementation of <a class="reference external" href="reference-Custom_Storage.html#storage_interface">storage_interface</a>. Behaves as a normal
bittorrent client. It is possible to derive from this class in order to
override some of its behavior, when implementing a custom storage.</p>
<pre class="literal-block">
class default_storage : public storage_interface
{
   explicit <strong>default_storage</strong> (storage_params const&amp; params, file_pool&amp;);
   bool <strong>tick</strong> () override;
   void <strong>release_files</strong> (storage_error&amp; ec) override;
   void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename
      , storage_error&amp; ec) override;
   void <strong>initialize</strong> (storage_error&amp; ec) override;
   void <strong>set_file_priority</strong> (aux::vector&lt;download_priority_t, file_index_t&gt;&amp; prio
      , storage_error&amp; ec) override;
   status_t <strong>move_storage</strong> (std::string const&amp; save_path
      , move_flags_t flags, storage_error&amp; ec) override;
   void <strong>delete_files</strong> (remove_flags_t options, storage_error&amp; ec) override;
   bool <strong>has_any_file</strong> (storage_error&amp; ec) override;
   bool <strong>verify_resume_data</strong> (add_torrent_params const&amp; rd
      , aux::vector&lt;std::string, file_index_t&gt; const&amp; links
      , storage_error&amp; error) override;
   int <strong>readv</strong> (span&lt;iovec_t const&gt; bufs
      , piece_index_t piece, int offset, open_mode_t flags, storage_error&amp; ec) override;
   int <strong>writev</strong> (span&lt;iovec_t const&gt; bufs
      , piece_index_t piece, int offset, open_mode_t flags, storage_error&amp; ec) override;
   file_storage const&amp; <strong>files</strong> () const;
};
</pre>
<a name="default_storage()"></a><div class="section" id="id12">
<h3>default_storage()</h3>
<pre class="literal-block">
explicit <strong>default_storage</strong> (storage_params const&amp; params, file_pool&amp;);
</pre>
<p>constructs the <a class="reference external" href="reference-Custom_Storage.html#default_storage">default_storage</a> based on the give <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> (fs).
<tt class="docutils literal">mapped</tt> is an optional argument (it may be nullptr). If non-nullptr it
represents the file mapping that have been made to the torrent before
adding it. That's where files are supposed to be saved and looked for
on disk. <tt class="docutils literal">save_path</tt> is the root save folder for this torrent.
<tt class="docutils literal">file_pool</tt> is the cache of file handles that the storage will use.
All files it opens will ask the <a class="reference external" href="reference-Custom_Storage.html#file_pool">file_pool</a> to open them. <tt class="docutils literal">file_prio</tt>
is a vector indicating the priority of files on startup. It may be
an empty vector. Any file whose index is not represented by the vector
(because the vector is too short) are assumed to have priority 1.
this is used to treat files with priority 0 slightly differently.</p>
<a name="files()"></a></div>
<div class="section" id="files">
<h3>files()</h3>
<pre class="literal-block">
file_storage const&amp; <strong>files</strong> () const;
</pre>
<p>if the files in this storage are mapped, returns the mapped
<a class="reference external" href="reference-Storage.html#file_storage">file_storage</a>, otherwise returns the original <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object.</p>
<a name="file_pool"></a></div>
</div>
<div class="section" id="file-pool">
<h2>file_pool</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/file_pool.hpp">libtorrent/file_pool.hpp</a>&quot;</p>
<p>this is an internal cache of open file handles. It's primarily used by
<a class="reference external" href="reference-Custom_Storage.html#storage_interface">storage_interface</a> implementations. It provides semi weak guarantees of
not opening more file handles than specified. Given multiple threads,
each with the ability to lock a file handle (via smart pointer), there
may be windows where more file handles are open.</p>
<pre class="literal-block">
struct file_pool : boost::noncopyable
{
   explicit <strong>file_pool</strong> (int size = 40);
   <strong>~file_pool</strong> ();
   file_handle <strong>open_file</strong> (storage_index_t st, std::string const&amp; p
      , file_index_t file_index, file_storage const&amp; fs, open_mode_t m
      , error_code&amp; ec);
   void <strong>release</strong> ();
   void <strong>release</strong> (storage_index_t st);
   void <strong>release</strong> (storage_index_t st, file_index_t file_index);
   void <strong>resize</strong> (int size);
   int <strong>size_limit</strong> () const;
   void <strong>close_oldest</strong> ();
};
</pre>
<a name="~file_pool()"></a>
<a name="file_pool()"></a><div class="section" id="file-pool-file-pool">
<h3>~file_pool() file_pool()</h3>
<pre class="literal-block">
explicit <strong>file_pool</strong> (int size = 40);
<strong>~file_pool</strong> ();
</pre>
<p><tt class="docutils literal">size</tt> specifies the number of allowed files handles
to hold open at any given time.</p>
<a name="open_file()"></a></div>
<div class="section" id="open-file">
<h3>open_file()</h3>
<pre class="literal-block">
file_handle <strong>open_file</strong> (storage_index_t st, std::string const&amp; p
      , file_index_t file_index, file_storage const&amp; fs, open_mode_t m
      , error_code&amp; ec);
</pre>
<p>return an open file handle to file at <tt class="docutils literal">file_index</tt> in the
<a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> <tt class="docutils literal">fs</tt> opened at save path <tt class="docutils literal">p</tt>. <tt class="docutils literal">m</tt> is the
file open mode (see <a class="reference external" href="file::open_mode_t">file::open_mode_t</a>).</p>
<a name="release()"></a></div>
<div class="section" id="release">
<h3>release()</h3>
<pre class="literal-block">
void <strong>release</strong> ();
void <strong>release</strong> (storage_index_t st);
void <strong>release</strong> (storage_index_t st, file_index_t file_index);
</pre>
<p>release all files belonging to the specified <a class="reference external" href="reference-Custom_Storage.html#storage_interface">storage_interface</a> (<tt class="docutils literal">st</tt>)
the overload that takes <tt class="docutils literal">file_index</tt> releases only the file with
that index in storage <tt class="docutils literal">st</tt>.</p>
<a name="resize()"></a></div>
<div class="section" id="resize">
<h3>resize()</h3>
<pre class="literal-block">
void <strong>resize</strong> (int size);
</pre>
<p>update the allowed number of open file handles to <tt class="docutils literal">size</tt>.</p>
<a name="size_limit()"></a></div>
<div class="section" id="size-limit">
<h3>size_limit()</h3>
<pre class="literal-block">
int <strong>size_limit</strong> () const;
</pre>
<p>returns the current limit of number of allowed open file handles held
by the <a class="reference external" href="reference-Custom_Storage.html#file_pool">file_pool</a>.</p>
<a name="close_oldest()"></a></div>
<div class="section" id="close-oldest">
<h3>close_oldest()</h3>
<pre class="literal-block">
void <strong>close_oldest</strong> ();
</pre>
<p>close the file that was opened least recently (i.e. not <em>accessed</em>
least recently). The purpose is to make the OS (really just windows)
clear and flush its disk cache associated with this file. We don't want
any file to stay open for too long, allowing the disk cache to accrue.</p>
</div>
</div>
</div>

    </div>
    </div>
    <div id="gradient"></div>
    <div id="footer">
    <table>
    <tr>
      <td><a href="index.html">home</a></td>
      <td><a href="https://blog.libtorrent.org">blog</a></td>
      <td><a href="utp.html">uTP</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/libtorrent/">download</a></td>
      <td><a href="reference.html">documentation</a></td>
      <td><a href="dht_store.html">DHT put extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/py-libtorrent/">python bindings</a></td>
      <td><a href="features.html">features</a></td>
      <td><a href="dht_sec.html">DHT security extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/p/libtorrent/mailman/libtorrent-discuss/">mailing list archive</a></td>
      <td><a href="contributing.html">contributing</a></td>
      <td><a href="streaming.html">streaming</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/arvidn/libtorrent/issues">report a bug</a></td>
      <td><a href="building.html">building</a></td>
      <td><a href="bittorrent.pdf">bittorrent slides</a></td>
    </tr>
    </table>
    </div>
    <div id="filler"></div>

</div>
</body>
</html>

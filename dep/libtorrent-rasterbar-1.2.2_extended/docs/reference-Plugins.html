<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>reference-Plugins.rst</title>
<meta name="author" content="Arvid Norberg, arvid&#64;libtorrent.org" />
<meta name=viewport content="width=device-width, initial-scale=1">
<script type="text/javascript">
/* <![CDATA[ */
    (function() {
        var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'https://api.flattr.com/js/0.6/load.js?mode=auto';
        t.parentNode.insertBefore(s, t);
    })();
/* ]]> */
</script>
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" type="text/css" href="rst.css" />
<style type="text/css">
/* Hides from IE-mac \*/
* html pre { height: 1%; }
/* End hide from IE-mac */
</style>
</head>
<body>
<div class="document">
    <div id="container">
    <a href="index.html"><table id="header">
    <tr><td id="orange"></td>
    <td id="logo">libtorrent</td></tr>
    </table></a>
    <div id="main">

<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Arvid Norberg, <a class="last reference external" href="mailto:arvid&#64;libtorrent.org">arvid&#64;libtorrent.org</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.2.2</td></tr>
</tbody>
</table>
<p><a class="reference external" href="reference.html">home</a></p>
<div class="section" id="plugins">
<h1>Plugins</h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#plugins" id="id83">Plugins</a><ul>
<li><a class="reference internal" href="#a-word-of-caution" id="id84">a word of caution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#plugin-interface" id="id85">plugin-interface</a></li>
<li><a class="reference internal" href="#custom-alerts" id="id86">custom alerts</a><ul>
<li><a class="reference internal" href="#plugin" id="id87">plugin</a></li>
<li><a class="reference internal" href="#torrent-plugin" id="id88">torrent_plugin</a></li>
<li><a class="reference internal" href="#peer-plugin" id="id89">peer_plugin</a></li>
<li><a class="reference internal" href="#crypto-plugin" id="id90">crypto_plugin</a></li>
<li><a class="reference internal" href="#create-ut-metadata-plugin" id="id91">create_ut_metadata_plugin()</a></li>
<li><a class="reference internal" href="#create-smart-ban-plugin" id="id92">create_smart_ban_plugin()</a></li>
<li><a class="reference internal" href="#create-ut-pex-plugin" id="id93">create_ut_pex_plugin()</a></li>
</ul>
</li>
</ul>
</div>
<p>libtorrent has a <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> interface for implementing extensions to the protocol.
These can be general extensions for transferring metadata or peer exchange
extensions, or it could be used to provide a way to customize the protocol
to fit a particular (closed) network.</p>
<p>In short, the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> interface makes it possible to:</p>
<ul class="simple">
<li>register extension messages (sent in the extension handshake), see
<a class="reference external" href="extension_protocol.html">extensions</a>.</li>
<li>add data and parse data from the extension handshake.</li>
<li>send extension messages and standard bittorrent messages.</li>
<li>override or block the handling of standard bittorrent messages.</li>
<li>save and restore state via the <a class="reference external" href="reference-Core.html#session">session</a> state</li>
<li>see all alerts that are posted</li>
</ul>
<div class="section" id="a-word-of-caution">
<h2>a word of caution</h2>
<p>Writing your own <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> is a very easy way to introduce serious bugs such as
dead locks and race conditions. Since a <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> has access to internal
structures it is also quite easy to sabotage libtorrent's operation.</p>
<p>All the callbacks are always called from the libtorrent network thread. In
case portions of your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> are called from other threads, typically the main
thread, you cannot use any of the member functions on the internal structures
in libtorrent, since those require being called from the libtorrent network
thread . Furthermore, you also need to synchronize your own shared data
within the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a>, to make sure it is not accessed at the same time from the
libtorrent thread (through a callback). If you need to send out a message
from another thread, it is advised to use an internal queue, and do the
actual sending in <tt class="docutils literal">tick()</tt>.</p>
<p>Since the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> interface gives you easy access to internal structures, it
is not supported as a stable API. Plugins should be considered specific to a
specific version of libtorrent. Although, in practice the internals mostly
don't change that dramatically.</p>
</div>
</div>
<div class="section" id="plugin-interface">
<h1>plugin-interface</h1>
<p>The <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> interface consists of three base classes that the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> may
implement. These are called <a class="reference external" href="reference-Plugins.html#plugin">plugin</a>, <a class="reference external" href="reference-Plugins.html#torrent_plugin">torrent_plugin</a> and <a class="reference external" href="reference-Plugins.html#peer_plugin">peer_plugin</a>.
They are found in the <tt class="docutils literal">&lt;libtorrent/extensions.hpp&gt;</tt> header.</p>
<p>These plugins are instantiated for each <a class="reference external" href="reference-Core.html#session">session</a>, torrent and possibly each peer,
respectively.</p>
<p>For plugins that only need per torrent state, it is enough to only implement
<tt class="docutils literal">torrent_plugin</tt> and pass a constructor function or function object to
<tt class="docutils literal"><span class="pre">session::add_extension()</span></tt> or <tt class="docutils literal"><span class="pre">torrent_handle::add_extension()</span></tt> (if the
torrent has already been started and you want to hook in the extension at
run-time).</p>
<p>The signature of the function is:</p>
<pre class="literal-block">
std::shared_ptr&lt;torrent_plugin&gt; (*)(torrent_handle const&amp;, void*);
</pre>
<p>The second argument is the userdata passed to <tt class="docutils literal"><span class="pre">session::add_torrent()</span></tt> or
<tt class="docutils literal"><span class="pre">torrent_handle::add_extension()</span></tt>.</p>
<p>The function should return a <tt class="docutils literal"><span class="pre">std::shared_ptr&lt;torrent_plugin&gt;</span></tt> which
may or may not be 0. If it is a nullptr, the extension is simply ignored
for this torrent. If it is a valid pointer (to a class inheriting
<tt class="docutils literal">torrent_plugin</tt>), it will be associated with this torrent and callbacks
will be made on torrent events.</p>
<p>For more elaborate plugins which require <a class="reference external" href="reference-Core.html#session">session</a> wide state, you would
implement <tt class="docutils literal">plugin</tt>, construct an object (in a <tt class="docutils literal"><span class="pre">std::shared_ptr</span></tt>) and pass
it in to <tt class="docutils literal"><span class="pre">session::add_extension()</span></tt>.</p>
</div>
<div class="section" id="custom-alerts">
<h1>custom alerts</h1>
<p>Since plugins are running within internal libtorrent threads, one convenient
way to communicate with the client is to post custom alerts.</p>
<p>The expected interface of any <a class="reference external" href="reference-Alerts.html#alert">alert</a>, apart from deriving from the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
base class, looks like this:</p>
<pre class="literal-block">
static const int alert_type = <em>&lt;unique alert ID&gt;</em>;
virtual int type() const { return alert_type; }

virtual std::string message() const;

static const alert_category_t static_category = <em>&lt;bitmask of alert::category_t flags&gt;</em>;
virtual alert_category_t category() const { return static_category; }

virtual char const* what() const { return <em>&lt;string literal of the name of this alert&gt;</em>; }
</pre>
<p>The <tt class="docutils literal">alert_type</tt> is used for the type-checking in <tt class="docutils literal">alert_cast</tt>. It must
not collide with any other <a class="reference external" href="reference-Alerts.html#alert">alert</a>. The built-in alerts in libtorrent will
not use <a class="reference external" href="reference-Alerts.html#alert">alert</a> type IDs greater than <tt class="docutils literal">user_alert_id</tt>. When defining your
own <a class="reference external" href="reference-Alerts.html#alert">alert</a>, make sure it's greater than this constant.</p>
<p><tt class="docutils literal">type()</tt> is the run-time equivalence of the <tt class="docutils literal">alert_type</tt>.</p>
<p>The <tt class="docutils literal">message()</tt> virtual function is expected to construct a useful
string representation of the <a class="reference external" href="reference-Alerts.html#alert">alert</a> and the event or data it represents.
Something convenient to put in a log file for instance.</p>
<p><tt class="docutils literal">clone()</tt> is used internally to copy alerts. The suggested implementation
of simply allocating a new instance as a copy of <tt class="docutils literal">*this</tt> is all that's
expected.</p>
<p>The static category is required for checking whether or not the category
for a specific <a class="reference external" href="reference-Alerts.html#alert">alert</a> is enabled or not, without instantiating the <a class="reference external" href="reference-Alerts.html#alert">alert</a>.
The <tt class="docutils literal">category</tt> virtual function is the run-time equivalence.</p>
<p>The <tt class="docutils literal">what()</tt> virtual function may simply be a string literal of the class
name of your <a class="reference external" href="reference-Alerts.html#alert">alert</a>.</p>
<p>For more information, see the <a class="reference external" href="reference-Alerts.html">alert section</a>.</p>
<a name="plugin"></a><div class="section" id="plugin">
<h2>plugin</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/extensions.hpp">libtorrent/extensions.hpp</a>&quot;</p>
<p>this is the base class for a <a class="reference external" href="reference-Core.html#session">session</a> <a class="reference external" href="reference-Plugins.html#plugin">plugin</a>. One primary feature
is that it is notified of all torrents that are added to the <a class="reference external" href="reference-Core.html#session">session</a>,
and can add its own torrent_plugins.</p>
<pre class="literal-block">
struct plugin
{
   virtual feature_flags_t <strong>implemented_features</strong> ();
   virtual std::shared_ptr&lt;torrent_plugin&gt; <strong>new_torrent</strong> (torrent_handle const&amp;, void*);
   virtual void <strong>added</strong> (session_handle const&amp;);
   virtual bool <strong>on_dht_request</strong> (string_view <em>/* query */</em>
      , udp::endpoint const&amp; <em>/* source */</em>, bdecode_node const&amp; <em>/* message */</em>
      , entry&amp; <em>/* response */</em>);
   virtual void <strong>on_alert</strong> (alert const*);
   virtual bool <strong>on_unknown_torrent</strong> (sha1_hash const&amp; <em>/* info_hash */</em>
      , peer_connection_handle const&amp; <em>/* pc */</em>, add_torrent_params&amp; <em>/* p */</em>);
   virtual void <strong>on_tick</strong> ();
   virtual uint64_t <strong>get_unchoke_priority</strong> (peer_connection_handle const&amp; <em>/* peer */</em>);
   virtual void <strong>save_state</strong> (entry&amp;);
   virtual void <strong>load_state</strong> (bdecode_node const&amp;);

   static constexpr feature_flags_t optimistic_unchoke_feature = 1_bit;
   static constexpr feature_flags_t tick_feature = 2_bit;
   static constexpr feature_flags_t dht_request_feature = 3_bit;
   static constexpr feature_flags_t alert_feature = 4_bit;
};
</pre>
<a name="implemented_features()"></a><div class="section" id="implemented-features">
<h3>implemented_features()</h3>
<pre class="literal-block">
virtual feature_flags_t <strong>implemented_features</strong> ();
</pre>
<p>This function is expected to return a bitmask indicating which features
this <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> implements. Some callbacks on this object may not be called
unless the corresponding feature flag is returned here. Note that
callbacks may still be called even if the corresponding feature is not
specified in the return value here. See feature_flags_t for possible
flags to return.</p>
<a name="new_torrent()"></a></div>
<div class="section" id="new-torrent">
<h3>new_torrent()</h3>
<pre class="literal-block">
virtual std::shared_ptr&lt;torrent_plugin&gt; <strong>new_torrent</strong> (torrent_handle const&amp;, void*);
</pre>
<p>this is called by the <a class="reference external" href="reference-Core.html#session">session</a> every time a new torrent is added.
The <tt class="docutils literal">torrent*</tt> points to the internal torrent object created
for the new torrent. The <tt class="docutils literal">void*</tt> is the userdata pointer as
passed in via <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a>.</p>
<p>If the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> returns a <a class="reference external" href="reference-Plugins.html#torrent_plugin">torrent_plugin</a> instance, it will be added
to the new torrent. Otherwise, return an empty shared_ptr to a
<a class="reference external" href="reference-Plugins.html#torrent_plugin">torrent_plugin</a> (the default).</p>
<a name="added()"></a></div>
<div class="section" id="added">
<h3>added()</h3>
<pre class="literal-block">
virtual void <strong>added</strong> (session_handle const&amp;);
</pre>
<p>called when <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> is added to a <a class="reference external" href="reference-Core.html#session">session</a></p>
<a name="on_dht_request()"></a></div>
<div class="section" id="on-dht-request">
<h3>on_dht_request()</h3>
<pre class="literal-block">
virtual bool <strong>on_dht_request</strong> (string_view <em>/* query */</em>
      , udp::endpoint const&amp; <em>/* source */</em>, bdecode_node const&amp; <em>/* message */</em>
      , entry&amp; <em>/* response */</em>);
</pre>
<p>called when a dht request is received.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> expects this to be called, make sure to include the flag
<tt class="docutils literal">dht_request_feature</tt> in the return value from <a class="reference external" href="reference-Plugins.html#implemented_features()">implemented_features()</a>.</p>
<a name="on_alert()"></a></div>
<div class="section" id="on-alert">
<h3>on_alert()</h3>
<pre class="literal-block">
virtual void <strong>on_alert</strong> (alert const*);
</pre>
<p>called when an <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted alerts that are filtered are not posted.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> expects this to be called, make sure to include the flag
<tt class="docutils literal">alert_feature</tt> in the return value from <a class="reference external" href="reference-Plugins.html#implemented_features()">implemented_features()</a>.</p>
<a name="on_unknown_torrent()"></a></div>
<div class="section" id="on-unknown-torrent">
<h3>on_unknown_torrent()</h3>
<pre class="literal-block">
virtual bool <strong>on_unknown_torrent</strong> (sha1_hash const&amp; <em>/* info_hash */</em>
      , peer_connection_handle const&amp; <em>/* pc */</em>, add_torrent_params&amp; <em>/* p */</em>);
</pre>
<p>return true if the <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> should be added</p>
<a name="on_tick()"></a></div>
<div class="section" id="on-tick">
<h3>on_tick()</h3>
<pre class="literal-block">
virtual void <strong>on_tick</strong> ();
</pre>
<p>called once per second.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> expects this to be called, make sure to include the flag
<tt class="docutils literal">tick_feature</tt> in the return value from <a class="reference external" href="reference-Plugins.html#implemented_features()">implemented_features()</a>.</p>
<a name="get_unchoke_priority()"></a></div>
<div class="section" id="get-unchoke-priority">
<h3>get_unchoke_priority()</h3>
<pre class="literal-block">
virtual uint64_t <strong>get_unchoke_priority</strong> (peer_connection_handle const&amp; <em>/* peer */</em>);
</pre>
<p>called when choosing peers to optimistically unchoke. The return value
indicates the peer's priority for unchoking. Lower return values
correspond to higher priority. Priorities above 2^63-1 are reserved.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> has no priority to assign a peer it should return 2^64-1.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> expects this to be called, make sure to include the flag
<tt class="docutils literal">optimistic_unchoke_feature</tt> in the return value from <a class="reference external" href="reference-Plugins.html#implemented_features()">implemented_features()</a>.
If multiple plugins implement this function the lowest return value
(i.e. the highest priority) is used.</p>
<a name="save_state()"></a></div>
<div class="section" id="save-state">
<h3>save_state()</h3>
<pre class="literal-block">
virtual void <strong>save_state</strong> (entry&amp;);
</pre>
<p>called when saving settings state</p>
<a name="load_state()"></a></div>
<div class="section" id="load-state">
<h3>load_state()</h3>
<pre class="literal-block">
virtual void <strong>load_state</strong> (bdecode_node const&amp;);
</pre>
<p>called when loading settings state</p>
<a name="optimistic_unchoke_feature"></a><dl class="docutils">
<dt>optimistic_unchoke_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to alter the order of the
optimistic unchoke of peers. i.e. have the on_optimistic_unchoke()
callback be called.</dd>
</dl>
<a name="tick_feature"></a><dl class="docutils">
<dt>tick_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to have <a class="reference external" href="reference-Plugins.html#on_tick()">on_tick()</a> called</dd>
</dl>
<a name="dht_request_feature"></a><dl class="docutils">
<dt>dht_request_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to have <a class="reference external" href="reference-Plugins.html#on_dht_request()">on_dht_request()</a>
called</dd>
</dl>
<a name="alert_feature"></a><dl class="docutils">
<dt>alert_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to have <a class="reference external" href="reference-Plugins.html#on_alert()">on_alert()</a>
called</dd>
</dl>
<a name="torrent_plugin"></a></div>
</div>
<div class="section" id="torrent-plugin">
<h2>torrent_plugin</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/extensions.hpp">libtorrent/extensions.hpp</a>&quot;</p>
<p>Torrent plugins are associated with a single torrent and have a number
of functions called at certain events. Many of its functions have the
ability to change or override the default libtorrent behavior.</p>
<pre class="literal-block">
struct torrent_plugin
{
   virtual std::shared_ptr&lt;peer_plugin&gt; <strong>new_connection</strong> (peer_connection_handle const&amp;);
   virtual void <strong>on_piece_failed</strong> (piece_index_t);
   virtual void <strong>on_piece_pass</strong> (piece_index_t);
   virtual void <strong>tick</strong> ();
   virtual bool <strong>on_resume</strong> ();
   virtual bool <strong>on_pause</strong> ();
   virtual void <strong>on_files_checked</strong> ();
   virtual void <strong>on_state</strong> (torrent_status::state_t);
   virtual void <strong>on_add_peer</strong> (tcp::endpoint const&amp;,
      peer_source_flags_t, add_peer_flags_t);

   static constexpr add_peer_flags_t first_time = 1_bit;
   static constexpr add_peer_flags_t filtered = 2_bit;
};
</pre>
<a name="new_connection()"></a><div class="section" id="new-connection">
<h3>new_connection()</h3>
<pre class="literal-block">
virtual std::shared_ptr&lt;peer_plugin&gt; <strong>new_connection</strong> (peer_connection_handle const&amp;);
</pre>
<p>This function is called each time a new peer is connected to the torrent. You
may choose to ignore this by just returning a default constructed
<tt class="docutils literal">shared_ptr</tt> (in which case you don't need to override this member
function).</p>
<p>If you need an extension to the peer connection (which most plugins do) you
are supposed to return an instance of your <a class="reference external" href="reference-Plugins.html#peer_plugin">peer_plugin</a> class. Which in
turn will have its hook functions called on event specific to that peer.</p>
<p>The <tt class="docutils literal">peer_connection_handle</tt> will be valid as long as the <tt class="docutils literal">shared_ptr</tt>
is being held by the torrent object. So, it is generally a good idea to not
keep a <tt class="docutils literal">shared_ptr</tt> to your own <a class="reference external" href="reference-Plugins.html#peer_plugin">peer_plugin</a>. If you want to keep references
to it, use <tt class="docutils literal">weak_ptr</tt>.</p>
<p>If this function throws an exception, the connection will be closed.</p>
<a name="on_piece_failed()"></a>
<a name="on_piece_pass()"></a></div>
<div class="section" id="on-piece-failed-on-piece-pass">
<h3>on_piece_failed() on_piece_pass()</h3>
<pre class="literal-block">
virtual void <strong>on_piece_failed</strong> (piece_index_t);
virtual void <strong>on_piece_pass</strong> (piece_index_t);
</pre>
<p>These hooks are called when a piece passes the hash check or fails the hash
check, respectively. The <tt class="docutils literal">index</tt> is the piece index that was downloaded.
It is possible to access the list of peers that participated in sending the
piece through the <tt class="docutils literal">torrent</tt> and the <tt class="docutils literal">piece_picker</tt>.</p>
<a name="tick()"></a></div>
<div class="section" id="tick">
<h3>tick()</h3>
<pre class="literal-block">
virtual void <strong>tick</strong> ();
</pre>
<p>This hook is called approximately once per second. It is a way of making it
easy for plugins to do timed events, for sending messages or whatever.</p>
<a name="on_resume()"></a>
<a name="on_pause()"></a></div>
<div class="section" id="on-resume-on-pause">
<h3>on_resume() on_pause()</h3>
<pre class="literal-block">
virtual bool <strong>on_resume</strong> ();
virtual bool <strong>on_pause</strong> ();
</pre>
<p>These hooks are called when the torrent is paused and resumed respectively.
The return value indicates if the event was handled. A return value of
<tt class="docutils literal">true</tt> indicates that it was handled, and no other <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> after this one
will have this hook function called, and the standard handler will also not be
invoked. So, returning true effectively overrides the standard behavior of
pause or resume.</p>
<p>Note that if you call <tt class="docutils literal">pause()</tt> or <tt class="docutils literal">resume()</tt> on the torrent from your
handler it will recurse back into your handler, so in order to invoke the
standard handler, you have to keep your own state on whether you want standard
behavior or overridden behavior.</p>
<a name="on_files_checked()"></a></div>
<div class="section" id="on-files-checked">
<h3>on_files_checked()</h3>
<pre class="literal-block">
virtual void <strong>on_files_checked</strong> ();
</pre>
<p>This function is called when the initial files of the torrent have been
checked. If there are no files to check, this function is called immediately.</p>
<p>i.e. This function is always called when the torrent is in a state where it
can start downloading.</p>
<a name="on_state()"></a></div>
<div class="section" id="on-state">
<h3>on_state()</h3>
<pre class="literal-block">
virtual void <strong>on_state</strong> (torrent_status::state_t);
</pre>
<p>called when the torrent changes state
the state is one of <a class="reference external" href="reference-Core.html#state_t">torrent_status::state_t</a>
enum members</p>
<a name="on_add_peer()"></a></div>
<div class="section" id="on-add-peer">
<h3>on_add_peer()</h3>
<pre class="literal-block">
virtual void <strong>on_add_peer</strong> (tcp::endpoint const&amp;,
      peer_source_flags_t, add_peer_flags_t);
</pre>
<p>called every time a new peer is added to the peer list.
This is before the peer is connected to. For <tt class="docutils literal">flags</tt>, see
torrent_plugin::flags_t. The <tt class="docutils literal">source</tt> argument refers to
the source where we learned about this peer from. It's a
bitmask, because many sources may have told us about the same
peer. For peer source flags, see peer_info::peer_source_flags.</p>
<a name="first_time"></a><dl class="docutils">
<dt>first_time</dt>
<dd>this is the first time we see this peer</dd>
</dl>
<a name="filtered"></a><dl class="docutils">
<dt>filtered</dt>
<dd>this peer was not added because it was
filtered by the IP filter</dd>
</dl>
<a name="peer_plugin"></a></div>
</div>
<div class="section" id="peer-plugin">
<h2>peer_plugin</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/extensions.hpp">libtorrent/extensions.hpp</a>&quot;</p>
<p>peer plugins are associated with a specific peer. A peer could be
both a regular bittorrent peer (<tt class="docutils literal">bt_peer_connection</tt>) or one of the
web seed connections (<tt class="docutils literal">web_peer_connection</tt> or <tt class="docutils literal">http_seed_connection</tt>).
In order to only attach to certain peers, make your
torrent_plugin::new_connection only return a <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> for certain peer
connection types</p>
<pre class="literal-block">
struct peer_plugin
{
   virtual string_view <strong>type</strong> () const;
   virtual void <strong>add_handshake</strong> (entry&amp;);
   virtual void <strong>on_disconnect</strong> (error_code const&amp;);
   virtual void <strong>on_connected</strong> ();
   virtual bool <strong>on_handshake</strong> (span&lt;char const&gt;);
   virtual bool <strong>on_extension_handshake</strong> (bdecode_node const&amp;);
   virtual bool <strong>on_bitfield</strong> (bitfield const&amp; <em>/*bitfield*/</em>);
   virtual bool <strong>on_dont_have</strong> (piece_index_t);
   virtual bool <strong>on_request</strong> (peer_request const&amp;);
   virtual bool <strong>on_unchoke</strong> ();
   virtual bool <strong>on_interested</strong> ();
   virtual bool <strong>on_have_all</strong> ();
   virtual bool <strong>on_allowed_fast</strong> (piece_index_t);
   virtual bool <strong>on_have_none</strong> ();
   virtual bool <strong>on_choke</strong> ();
   virtual bool <strong>on_not_interested</strong> ();
   virtual bool <strong>on_have</strong> (piece_index_t);
   virtual bool <strong>on_piece</strong> (peer_request const&amp; <em>/*piece*/</em>
      , span&lt;char const&gt; <em>/*buf*/</em>);
   virtual bool <strong>on_suggest</strong> (piece_index_t);
   virtual bool <strong>on_reject</strong> (peer_request const&amp;);
   virtual bool <strong>on_cancel</strong> (peer_request const&amp;);
   virtual void <strong>sent_unchoke</strong> ();
   virtual void <strong>sent_payload</strong> (int <em>/* bytes */</em>);
   virtual bool <strong>can_disconnect</strong> (error_code const&amp; <em>/*ec*/</em>);
   virtual bool <strong>on_extended</strong> (int <em>/*length*/</em>, int <em>/*msg*/</em>,
      span&lt;char const&gt; <em>/*body*/</em>);
   virtual bool <strong>on_unknown_message</strong> (int <em>/*length*/</em>, int <em>/*msg*/</em>,
      span&lt;char const&gt; <em>/*body*/</em>);
   virtual void <strong>on_piece_failed</strong> (piece_index_t);
   virtual void <strong>on_piece_pass</strong> (piece_index_t);
   virtual void <strong>tick</strong> ();
   virtual bool <strong>write_request</strong> (peer_request const&amp;);
};
</pre>
<a name="type()"></a><div class="section" id="type">
<h3>type()</h3>
<pre class="literal-block">
virtual string_view <strong>type</strong> () const;
</pre>
<p>This function is expected to return the name of
the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a>.</p>
<a name="add_handshake()"></a></div>
<div class="section" id="add-handshake">
<h3>add_handshake()</h3>
<pre class="literal-block">
virtual void <strong>add_handshake</strong> (entry&amp;);
</pre>
<p>can add entries to the extension handshake
this is not called for web seeds</p>
<a name="on_disconnect()"></a></div>
<div class="section" id="on-disconnect">
<h3>on_disconnect()</h3>
<pre class="literal-block">
virtual void <strong>on_disconnect</strong> (error_code const&amp;);
</pre>
<p>called when the peer is being disconnected.</p>
<a name="on_connected()"></a></div>
<div class="section" id="on-connected">
<h3>on_connected()</h3>
<pre class="literal-block">
virtual void <strong>on_connected</strong> ();
</pre>
<p>called when the peer is successfully connected. Note that
incoming connections will have been connected by the time
the peer <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> is attached to it, and won't have this hook
called.</p>
<a name="on_handshake()"></a></div>
<div class="section" id="on-handshake">
<h3>on_handshake()</h3>
<pre class="literal-block">
virtual bool <strong>on_handshake</strong> (span&lt;char const&gt;);
</pre>
<p>this is called when the initial bittorrent handshake is received.
Returning false means that the other end doesn't support this extension
and will remove it from the list of plugins. this is not called for web
seeds</p>
<a name="on_extension_handshake()"></a></div>
<div class="section" id="on-extension-handshake">
<h3>on_extension_handshake()</h3>
<pre class="literal-block">
virtual bool <strong>on_extension_handshake</strong> (bdecode_node const&amp;);
</pre>
<p>called when the extension handshake from the other end is received
if this returns false, it means that this extension isn't
supported by this peer. It will result in this <a class="reference external" href="reference-Plugins.html#peer_plugin">peer_plugin</a>
being removed from the peer_connection and destructed.
this is not called for web seeds</p>
<a name="on_bitfield()"></a>
<a name="on_have_none()"></a>
<a name="on_unchoke()"></a>
<a name="on_have()"></a>
<a name="on_choke()"></a>
<a name="on_request()"></a>
<a name="on_not_interested()"></a>
<a name="on_interested()"></a>
<a name="on_allowed_fast()"></a>
<a name="on_have_all()"></a>
<a name="on_dont_have()"></a></div>
<div class="section" id="on-bitfield-on-have-none-on-unchoke-on-have-on-choke-on-request-on-not-interested-on-interested-on-allowed-fast-on-have-all-on-dont-have">
<h3>on_bitfield() on_have_none() on_unchoke() on_have() on_choke() on_request() on_not_interested() on_interested() on_allowed_fast() on_have_all() on_dont_have()</h3>
<pre class="literal-block">
virtual bool <strong>on_bitfield</strong> (bitfield const&amp; <em>/*bitfield*/</em>);
virtual bool <strong>on_dont_have</strong> (piece_index_t);
virtual bool <strong>on_request</strong> (peer_request const&amp;);
virtual bool <strong>on_unchoke</strong> ();
virtual bool <strong>on_interested</strong> ();
virtual bool <strong>on_have_all</strong> ();
virtual bool <strong>on_allowed_fast</strong> (piece_index_t);
virtual bool <strong>on_have_none</strong> ();
virtual bool <strong>on_choke</strong> ();
virtual bool <strong>on_not_interested</strong> ();
virtual bool <strong>on_have</strong> (piece_index_t);
</pre>
<p>returning true from any of the message handlers
indicates that the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> has handled the message.
it will break the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> chain traversing and not let
anyone else handle the message, including the default
handler.</p>
<a name="on_piece()"></a></div>
<div class="section" id="on-piece">
<h3>on_piece()</h3>
<pre class="literal-block">
virtual bool <strong>on_piece</strong> (peer_request const&amp; <em>/*piece*/</em>
      , span&lt;char const&gt; <em>/*buf*/</em>);
</pre>
<p>This function is called when the peer connection is receiving
a piece. <tt class="docutils literal">buf</tt> points (non-owning pointer) to the data in an
internal immutable disk buffer. The length of the data is specified
in the <tt class="docutils literal">length</tt> member of the <tt class="docutils literal">piece</tt> parameter.
returns true to indicate that the piece is handled and the
rest of the logic should be ignored.</p>
<a name="sent_unchoke()"></a></div>
<div class="section" id="sent-unchoke">
<h3>sent_unchoke()</h3>
<pre class="literal-block">
virtual void <strong>sent_unchoke</strong> ();
</pre>
<p>called after a choke message has been sent to the peer</p>
<a name="sent_payload()"></a></div>
<div class="section" id="sent-payload">
<h3>sent_payload()</h3>
<pre class="literal-block">
virtual void <strong>sent_payload</strong> (int <em>/* bytes */</em>);
</pre>
<p>called after piece data has been sent to the peer
this can be used for stats book keeping</p>
<a name="can_disconnect()"></a></div>
<div class="section" id="can-disconnect">
<h3>can_disconnect()</h3>
<pre class="literal-block">
virtual bool <strong>can_disconnect</strong> (error_code const&amp; <em>/*ec*/</em>);
</pre>
<p>called when libtorrent think this peer should be disconnected.
if the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> returns false, the peer will not be disconnected.</p>
<a name="on_extended()"></a></div>
<div class="section" id="on-extended">
<h3>on_extended()</h3>
<pre class="literal-block">
virtual bool <strong>on_extended</strong> (int <em>/*length*/</em>, int <em>/*msg*/</em>,
      span&lt;char const&gt; <em>/*body*/</em>);
</pre>
<p>called when an extended message is received. If returning true,
the message is not processed by any other <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> and if false
is returned the next <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> in the chain will receive it to
be able to handle it. This is not called for web seeds.
thus function may be called more than once per incoming message, but
only the last of the calls will the <tt class="docutils literal">body</tt> size equal the <tt class="docutils literal">length</tt>.
i.e. Every time another fragment of the message is received, this
function will be called, until finally the whole message has been
received. The purpose of this is to allow early disconnects for invalid
messages and for reporting progress of receiving large messages.</p>
<a name="on_unknown_message()"></a></div>
<div class="section" id="on-unknown-message">
<h3>on_unknown_message()</h3>
<pre class="literal-block">
virtual bool <strong>on_unknown_message</strong> (int <em>/*length*/</em>, int <em>/*msg*/</em>,
      span&lt;char const&gt; <em>/*body*/</em>);
</pre>
<p>this is not called for web seeds</p>
<a name="on_piece_failed()"></a>
<a name="on_piece_pass()"></a></div>
<div class="section" id="id71">
<h3>on_piece_failed() on_piece_pass()</h3>
<pre class="literal-block">
virtual void <strong>on_piece_failed</strong> (piece_index_t);
virtual void <strong>on_piece_pass</strong> (piece_index_t);
</pre>
<p>called when a piece that this peer participated in either
fails or passes the hash_check</p>
<a name="tick()"></a></div>
<div class="section" id="id72">
<h3>tick()</h3>
<pre class="literal-block">
virtual void <strong>tick</strong> ();
</pre>
<p>called approximately once every second</p>
<a name="write_request()"></a></div>
<div class="section" id="write-request">
<h3>write_request()</h3>
<pre class="literal-block">
virtual bool <strong>write_request</strong> (peer_request const&amp;);
</pre>
<p>called each time a request message is to be sent. If true
is returned, the original request message won't be sent and
no other <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> will have this function called.</p>
<a name="crypto_plugin"></a></div>
</div>
<div class="section" id="crypto-plugin">
<h2>crypto_plugin</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/extensions.hpp">libtorrent/extensions.hpp</a>&quot;</p>
<pre class="literal-block">
struct crypto_plugin
{
   virtual void <strong>set_outgoing_key</strong> (span&lt;char const&gt; key) = 0;
   virtual void <strong>set_incoming_key</strong> (span&lt;char const&gt; key) = 0;
   <strong>encrypt</strong> (span&lt;span&lt;char&gt;&gt; <em>/*send_vec*/</em>) = 0;
   virtual std::tuple&lt;int, int, int&gt; <strong>decrypt</strong> (span&lt;span&lt;char&gt;&gt; <em>/*receive_vec*/</em>) = 0;
};
</pre>
<a name="decrypt()"></a><div class="section" id="decrypt">
<h3>decrypt()</h3>
<pre class="literal-block">
virtual std::tuple&lt;int, int, int&gt; <strong>decrypt</strong> (span&lt;span&lt;char&gt;&gt; <em>/*receive_vec*/</em>) = 0;
</pre>
<p>decrypt the provided buffers.
returns is a tuple representing the values
(consume, produce, packet_size)</p>
<p>consume is set to the number of bytes which should be trimmed from the
head of the buffers, default is 0</p>
<p>produce is set to the number of bytes of payload which are now ready to
be sent to the upper layer. default is the number of bytes passed in receive_vec</p>
<p>packet_size is set to the minimum number of bytes which must be read to
advance the next step of decryption. default is 0</p>
<a name="create_ut_metadata_plugin()"></a></div>
</div>
<div class="section" id="create-ut-metadata-plugin">
<h2>create_ut_metadata_plugin()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/extensions/ut_metadata.hpp">libtorrent/extensions/ut_metadata.hpp</a>&quot;</p>
<pre class="literal-block">
std::shared_ptr&lt;torrent_plugin&gt; <strong>create_ut_metadata_plugin</strong> (torrent_handle const&amp;, void*);
</pre>
<p>constructor function for the ut_metadata extension. The ut_metadata
extension allows peers to request the .torrent file (or more
specifically the 'info'-dictionary of the .torrent file) from each
other. This is the main building block in making magnet links work.
This extension is enabled by default unless explicitly disabled in
the <a class="reference external" href="reference-Core.html#session">session</a> constructor.</p>
<p>This can either be passed in the add_torrent_params::extensions field, or
via <a class="reference external" href="reference-Core.html#add_extension()">torrent_handle::add_extension()</a>.</p>
<a name="create_smart_ban_plugin()"></a></div>
<div class="section" id="create-smart-ban-plugin">
<h2>create_smart_ban_plugin()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/extensions/smart_ban.hpp">libtorrent/extensions/smart_ban.hpp</a>&quot;</p>
<pre class="literal-block">
std::shared_ptr&lt;torrent_plugin&gt; <strong>create_smart_ban_plugin</strong> (torrent_handle const&amp;, void*);
</pre>
<p>constructor function for the smart ban extension. The extension keeps
track of the data peers have sent us for failing pieces and once the
piece completes and passes the hash check bans the peers that turned
out to have sent corrupt data.
This function can either be passed in the add_torrent_params::extensions
field, or via <a class="reference external" href="reference-Core.html#add_extension()">torrent_handle::add_extension()</a>.</p>
<a name="create_ut_pex_plugin()"></a></div>
<div class="section" id="create-ut-pex-plugin">
<h2>create_ut_pex_plugin()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/extensions/ut_pex.hpp">libtorrent/extensions/ut_pex.hpp</a>&quot;</p>
<pre class="literal-block">
std::shared_ptr&lt;torrent_plugin&gt; <strong>create_ut_pex_plugin</strong> (torrent_handle const&amp;, void*);
</pre>
<p>constructor function for the ut_pex extension. The ut_pex
extension allows peers to gossip about their connections, allowing
the swarm stay well connected and peers aware of more peers in the
swarm. This extension is enabled by default unless explicitly disabled in
the <a class="reference external" href="reference-Core.html#session">session</a> constructor.</p>
<p>This can either be passed in the add_torrent_params::extensions field, or
via <a class="reference external" href="reference-Core.html#add_extension()">torrent_handle::add_extension()</a>.</p>
</div>
</div>

    </div>
    </div>
    <div id="gradient"></div>
    <div id="footer">
    <table>
    <tr>
      <td><a href="index.html">home</a></td>
      <td><a href="https://blog.libtorrent.org">blog</a></td>
      <td><a href="utp.html">uTP</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/libtorrent/">download</a></td>
      <td><a href="reference.html">documentation</a></td>
      <td><a href="dht_store.html">DHT put extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/py-libtorrent/">python bindings</a></td>
      <td><a href="features.html">features</a></td>
      <td><a href="dht_sec.html">DHT security extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/p/libtorrent/mailman/libtorrent-discuss/">mailing list archive</a></td>
      <td><a href="contributing.html">contributing</a></td>
      <td><a href="streaming.html">streaming</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/arvidn/libtorrent/issues">report a bug</a></td>
      <td><a href="building.html">building</a></td>
      <td><a href="bittorrent.pdf">bittorrent slides</a></td>
    </tr>
    </table>
    </div>
    <div id="filler"></div>

</div>
</body>
</html>

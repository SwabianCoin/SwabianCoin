<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>reference-Settings.rst</title>
<meta name="author" content="Arvid Norberg, arvid&#64;libtorrent.org" />
<meta name=viewport content="width=device-width, initial-scale=1">
<script type="text/javascript">
/* <![CDATA[ */
    (function() {
        var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'https://api.flattr.com/js/0.6/load.js?mode=auto';
        t.parentNode.insertBefore(s, t);
    })();
/* ]]> */
</script>
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" type="text/css" href="rst.css" />
<style type="text/css">
/* Hides from IE-mac \*/
* html pre { height: 1%; }
/* End hide from IE-mac */
</style>
</head>
<body>
<div class="document">
    <div id="container">
    <a href="index.html"><table id="header">
    <tr><td id="orange"></td>
    <td id="logo">libtorrent</td></tr>
    </table></a>
    <div id="main">

<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Arvid Norberg, <a class="last reference external" href="mailto:arvid&#64;libtorrent.org">arvid&#64;libtorrent.org</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.2.2</td></tr>
</tbody>
</table>
<p><a class="reference external" href="reference.html">home</a></p>
<div class="section" id="settings">
<h1>Settings</h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#settings" id="id80">Settings</a><ul>
<li><a class="reference internal" href="#settings-pack" id="id81">settings_pack</a></li>
<li><a class="reference internal" href="#min-memory-usage-high-performance-seed" id="id82">min_memory_usage() high_performance_seed()</a></li>
<li><a class="reference internal" href="#setting-by-name-name-for-setting" id="id83">setting_by_name() name_for_setting()</a></li>
<li><a class="reference internal" href="#default-settings" id="id84">default_settings()</a></li>
</ul>
</li>
</ul>
</div>
<p>You have some control over <a class="reference external" href="reference-Core.html#session">session</a> configuration through the session::apply_settings()
member function. To change one or more configuration options, create a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>
object and fill it with the settings to be set and pass it in to session::apply_settings().</p>
<p>The <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> object is a collection of settings updates that are applied
to the <a class="reference external" href="reference-Core.html#session">session</a> when passed to session::apply_settings(). It's empty when
constructed.</p>
<p>You have control over proxy and authorization settings and also the user-agent
that will be sent to the tracker. The user-agent will also be used to identify the
client with other peers.</p>
<a name="settings_pack"></a><div class="section" id="settings-pack">
<h2>settings_pack</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">settings_pack</tt> struct, contains the names of all settings as
enum values. These values are passed in to the <tt class="docutils literal">set_str()</tt>,
<tt class="docutils literal">set_int()</tt>, <tt class="docutils literal">set_bool()</tt> functions, to specify the setting to
change.</p>
<p>These are the available settings:</p>
<a name="user_agent"></a><table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="15%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>user_agent</td>
<td>string</td>
<td>&quot;libtorrent/&quot; LIBTORRENT_VERSION</td>
</tr>
</tbody>
</table>
<p>this is the client identification to the tracker. The recommended
format of this string is: &quot;ClientName/ClientVersion
libtorrent/libtorrentVersion&quot;. This name will not only be used when
making HTTP requests, but also when sending extended headers to
peers that support that extension. It may not contain r or n</p>
<a name="announce_ip"></a><table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="27%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_ip</td>
<td>string</td>
<td>nullptr</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">announce_ip</tt> is the ip address passed along to trackers as the
<tt class="docutils literal">&amp;ip=</tt> parameter. If left as the default, that parameter is
omitted.</p>
<a name="handshake_client_version"></a><table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="19%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>handshake_client_version</td>
<td>string</td>
<td>nullptr</td>
</tr>
</tbody>
</table>
<p>this is the client name and version identifier sent to peers in the
handshake message. If this is an empty string, the user_agent is
used instead</p>
<a name="outgoing_interfaces"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="21%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>outgoing_interfaces</td>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
</tbody>
</table>
<p>sets the network interface this <a class="reference external" href="reference-Core.html#session">session</a> will use when it opens
outgoing connections. By default, it binds outgoing connections to
INADDR_ANY and port 0 (i.e. let the OS decide). Ths parameter must
be a string containing one or more, comma separated, adapter names.
Adapter names on unix systems are of the form &quot;eth0&quot;, &quot;eth1&quot;,
&quot;tun0&quot;, etc. When specifying multiple interfaces, they will be
assigned in round-robin order. This may be useful for clients that
are multi-homed. Binding an outgoing connection to a local IP does
not necessarily make the connection via the associated NIC/Adapter.
Setting this to an empty string will disable binding of outgoing
connections.</p>
<a name="listen_interfaces"></a><table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="19%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_interfaces</td>
<td>string</td>
<td>&quot;0.0.0.0:6881</td>
</tr>
</tbody>
</table>
<p>a comma-separated list of (IP or device name, port) pairs. These are
the listen ports that will be opened for accepting incoming uTP and
TCP connections. It is possible to listen on multiple interfaces and
multiple ports. Binding to port 0 will make the operating system
pick the port. The default is &quot;0.0.0.0:6881,[::]:6881&quot;, which binds
to all interfaces on port 6881.</p>
<p>a port that has an &quot;s&quot; suffix will accept SSL connections. (note
that SSL sockets are not enabled by default).</p>
<p>if binding fails, the <a class="reference external" href="reference-Alerts.html#listen_failed_alert">listen_failed_alert</a> is posted. If or once a
socket binding succeeds, the <a class="reference external" href="reference-Alerts.html#listen_succeeded_alert">listen_succeeded_alert</a> is posted. There
may be multiple failures before a success.</p>
<p>For example:
<tt class="docutils literal"><span class="pre">[::1]:8888</span></tt> - will only accept connections on the IPv6 loopback
address on port 8888.</p>
<p><tt class="docutils literal">eth0:4444,eth1:4444</tt> - will accept connections on port 4444 on
any IP address bound to device <tt class="docutils literal">eth0</tt> or <tt class="docutils literal">eth1</tt>.</p>
<p><tt class="docutils literal"><span class="pre">[::]:0s</span></tt> - will accept SSL connections on a port chosen by the
OS. And not accept non-SSL connections at all.</p>
<p>Windows OS network adapter device name can be specified with GUID.
It can be obtained from &quot;netsh lan show interfaces&quot; command output.
GUID must be uppercased string embraced in curly brackets.
<tt class="docutils literal"><span class="pre">{E4F0B674-0DFC-48BB-98A5-2AA730BDB6D6}::7777</span></tt> - will accept
connections on port 7777 on adapter with this GUID.</p>
<a name="proxy_hostname"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="24%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_hostname</td>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
</tbody>
</table>
<p>when using a poxy, this is the hostname where the proxy is running
see proxy_type.</p>
<a name="proxy_username"></a>
<a name="proxy_password"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="24%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_username</td>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
<tr><td>proxy_password</td>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
</tbody>
</table>
<p>when using a proxy, these are the credentials (if any) to use when
connecting to it. see proxy_type</p>
<a name="i2p_hostname"></a><table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="26%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>i2p_hostname</td>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
</tbody>
</table>
<p>sets the <a class="reference external" href="http://www.i2p2.de">i2p</a> SAM bridge to connect to. set the port with the
<tt class="docutils literal">i2p_port</tt> setting.</p>
<a name="peer_fingerprint"></a><table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_fingerprint</td>
<td>string</td>
<td>&quot;-LT1220-&quot;</td>
</tr>
</tbody>
</table>
<p>this is the fingerprint for the client. It will be used as the
prefix to the peer_id. If this is 20 bytes (or longer) it will be
truncated to 20 bytes and used as the entire peer-id</p>
<p>There is a utility function, <a class="reference external" href="reference-Core.html#generate_fingerprint()">generate_fingerprint()</a> that can be used
to generate a standard client peer ID fingerprint prefix.</p>
<a name="dht_bootstrap_nodes"></a><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="14%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_bootstrap_nodes</td>
<td>string</td>
<td>&quot;dht.libtorrent.org:25401&quot;</td>
</tr>
</tbody>
</table>
<p>This is a comma-separated list of IP port-pairs. They will be added
to the DHT node (if it's enabled) as back-up nodes in case we don't
know of any. This setting will contain one or more bootstrap nodes
by default.</p>
<p>Changing these after the DHT has been started may not have any
effect until the DHT is restarted.</p>
<a name="allow_multiple_connections_per_ip"></a><table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="12%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_multiple_connections_per_ip</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>determines if connections from the same IP address as existing
connections should be rejected or not. Multiple connections from
the same IP address is not allowed by default, to prevent abusive
behavior by peers. It may be useful to allow such connections in
cases where simulations are run on the same machine, and all peers
in a swarm has the same IP address.</p>
<a name="send_redundant_have"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>send_redundant_have</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">send_redundant_have</tt> controls if have messages will be sent to
peers that already have the piece. This is typically not necessary,
but it might be necessary for collecting statistics in some cases.</p>
<a name="use_dht_as_fallback"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>use_dht_as_fallback</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">use_dht_as_fallback</tt> determines how the DHT is used. If this is
true, the DHT will only be used for torrents where all trackers in
its tracker list has failed. Either by an explicit error message or
a time out. This is false by default, which means the DHT is used
by default regardless of if the trackers fail or not.</p>
<a name="upnp_ignore_nonrouters"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>upnp_ignore_nonrouters</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">upnp_ignore_nonrouters</tt> indicates whether or not the UPnP
implementation should ignore any broadcast response from a device
whose address is not the configured router for this machine. i.e.
it's a way to not talk to other people's routers by mistake.</p>
<a name="use_parole_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>use_parole_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">use_parole_mode</tt> specifies if parole mode should be used. Parole
mode means that peers that participate in pieces that fail the hash
check are put in a mode where they are only allowed to download
whole pieces. If the whole piece a peer in parole mode fails the
hash check, it is banned. If a peer participates in a piece that
passes the hash check, it is taken out of parole mode.</p>
<a name="use_read_cache"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="19%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>use_read_cache</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>enable and disable caching of blocks read from disk. the purpose of
the read cache is partly read-ahead of requests but also to avoid
reading blocks back from the disk multiple times for popular
pieces.</p>
<a name="coalesce_reads"></a>
<a name="coalesce_writes"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>coalesce_reads</td>
<td>bool</td>
<td>false</td>
</tr>
<tr><td>coalesce_writes</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>allocate separate, contiguous, buffers for read and write calls.
Only used where writev/readv cannot be used will use more RAM but
may improve performance</p>
<a name="auto_manage_prefer_seeds"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_prefer_seeds</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>prefer seeding torrents when determining which torrents to give
active slots to, the default is false which gives preference to
downloading torrents</p>
<a name="dont_count_slow_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dont_count_slow_torrents</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if <tt class="docutils literal">dont_count_slow_torrents</tt> is true, torrents without any
payload transfers are not subject to the <tt class="docutils literal">active_seeds</tt> and
<tt class="docutils literal">active_downloads</tt> limits. This is intended to make it more
likely to utilize all available bandwidth, and avoid having
torrents that don't transfer anything block the active slots.</p>
<a name="close_redundant_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>close_redundant_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">close_redundant_connections</tt> specifies whether libtorrent should
close connections where both ends have no utility in keeping the
connection open. For instance if both ends have completed their
downloads, there's no point in keeping it open.</p>
<a name="prioritize_partial_pieces"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prioritize_partial_pieces</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>If <tt class="docutils literal">prioritize_partial_pieces</tt> is true, partial pieces are picked
before pieces that are more rare. If false, rare pieces are always
prioritized, unless the number of partial pieces is growing out of
proportion.</p>
<a name="rate_limit_ip_overhead"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>rate_limit_ip_overhead</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if set to true, the estimated TCP/IP overhead is drained from the
rate limiters, to avoid exceeding the limits with the total traffic</p>
<a name="announce_to_all_tiers"></a>
<a name="announce_to_all_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_to_all_tiers</td>
<td>bool</td>
<td>false</td>
</tr>
<tr><td>announce_to_all_trackers</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">announce_to_all_trackers</tt> controls how multi tracker torrents
are treated. If this is set to true, all trackers in the same tier
are announced to in parallel. If all trackers in tier 0 fails, all
trackers in tier 1 are announced as well. If it's set to false, the
behavior is as defined by the multi tracker specification. It
defaults to false, which is the same behavior previous versions of
libtorrent has had as well.</p>
<p><tt class="docutils literal">announce_to_all_tiers</tt> also controls how multi tracker torrents
are treated. When this is set to true, one tracker from each tier
is announced to. This is the uTorrent behavior. This is false by
default in order to comply with the multi-tracker specification.</p>
<a name="prefer_udp_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_udp_trackers</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">prefer_udp_trackers</tt> is true by default. It means that trackers
may be rearranged in a way that udp trackers are always tried
before http trackers for the same hostname. Setting this to false
means that the trackers' tier is respected and there's no
preference of one protocol over another.</p>
<a name="strict_super_seeding"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>strict_super_seeding</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">strict_super_seeding</tt> when this is set to true, a piece has to
have been forwarded to a third peer before another one is handed
out. This is the traditional definition of super seeding.</p>
<a name="disable_hash_checks"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>disable_hash_checks</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set to true, all data downloaded from peers will be assumed to
be correct, and not tested to match the hashes in the torrent this
is only useful for simulation and testing purposes (typically
combined with disabled_storage)</p>
<a name="allow_i2p_mixed"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_i2p_mixed</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>if this is true, i2p torrents are allowed to also get peers from
other sources than the tracker, and connect to regular IPs, not
providing any anonymization. This may be useful if the user is not
interested in the anonymization of i2p, but still wants to be able
to connect to i2p peers.</p>
<a name="volatile_read_cache"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>volatile_read_cache</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">volatile_read_cache</tt>, if this is set to true, read cache blocks
that are hit by peer read requests are removed from the disk cache
to free up more space. This is useful if you don't expect the disk
cache to create any cache hits from other peers than the one who
triggered the cache line to be read into the cache in the first
place.</p>
<a name="no_atime_storage"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_atime_storage</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">no_atime_storage</tt> this is a linux-only option and passes in the
<tt class="docutils literal">O_NOATIME</tt> to <tt class="docutils literal">open()</tt> when opening files. This may lead to
some disk performance improvements.</p>
<a name="incoming_starts_queued_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>incoming_starts_queued_torrents</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">incoming_starts_queued_torrents</tt> defaults to false. If a torrent
has been paused by the auto managed feature in libtorrent, i.e. the
torrent is paused and auto managed, this feature affects whether or
not it is automatically started on an incoming connection. The main
reason to queue torrents, is not to make them unavailable, but to
save on the overhead of announcing to the trackers, the DHT and to
avoid spreading one's unchoke slots too thin. If a peer managed to
find us, even though we're no in the torrent anymore, this setting
can make us start the torrent and serve it.</p>
<a name="report_true_downloaded"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_true_downloaded</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set to true, the downloaded counter sent to trackers will
include the actual number of payload bytes downloaded including
redundant bytes. If set to false, it will not include any redundancy
bytes</p>
<a name="strict_end_game_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>strict_end_game_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">strict_end_game_mode</tt> defaults to true, and controls when a
block may be requested twice. If this is <tt class="docutils literal">true</tt>, a block may only
be requested twice when there's ay least one request to every piece
that's left to download in the torrent. This may slow down progress
on some pieces sometimes, but it may also avoid downloading a lot
of redundant bytes. If this is <tt class="docutils literal">false</tt>, libtorrent attempts to
use each peer connection to its max, by always requesting
something, even if it means requesting something that has been
requested from another peer already.</p>
<a name="broadcast_lsd"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>broadcast_lsd</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if <tt class="docutils literal">broadcast_lsd</tt> is set to true, the local peer discovery (or
Local Service Discovery) will not only use IP multicast, but also
broadcast its messages. This can be useful when running on networks
that don't support multicast. Since broadcast messages might be
expensive and disruptive on networks, only every 8th announce uses
broadcast.</p>
<a name="enable_outgoing_utp"></a>
<a name="enable_incoming_utp"></a>
<a name="enable_outgoing_tcp"></a>
<a name="enable_incoming_tcp"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_outgoing_utp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_incoming_utp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_outgoing_tcp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_incoming_tcp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when set to true, libtorrent will try to make outgoing utp
connections controls whether libtorrent will accept incoming
connections or make outgoing connections of specific type.</p>
<a name="no_recheck_incomplete_resume"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_recheck_incomplete_resume</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">no_recheck_incomplete_resume</tt> determines if the storage should
check the whole files when resume data is incomplete or missing or
whether it should simply assume we don't have any of the data. By
default, this is determined by the existence of any of the files.
By setting this setting to true, the files won't be checked, but
will go straight to download mode.</p>
<a name="anonymous_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="19%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>anonymous_mode</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">anonymous_mode</tt> defaults to false. When set to true, the client
tries to hide its identity to a certain degree. The user-agent will be
reset to an empty string (except for private torrents). Trackers
will only be used if they are using a proxy server.
The listen sockets are closed, and incoming
connections will only be accepted through a SOCKS5 or I2P proxy (if
a peer proxy is set up and is run on the same machine as the
tracker proxy). Since no incoming connections are accepted,
NAT-PMP, UPnP, DHT and local peer discovery are all turned off when
this setting is enabled.</p>
<p>If you're using I2P, it might make sense to enable anonymous mode
as well.</p>
<a name="report_web_seed_downloads"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_web_seed_downloads</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>specifies whether downloads from web seeds is reported to the
tracker or not. Defaults to on. Turning it off also excludes web
seed traffic from other stats and download rate reporting via the
libtorrent API.</p>
<a name="seeding_outgoing_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seeding_outgoing_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">seeding_outgoing_connections</tt> determines if seeding (and
finished) torrents should attempt to make outgoing connections or
not. By default this is true. It may be set to false in very
specific applications where the cost of making outgoing connections
is high, and there are no or small benefits of doing so. For
instance, if no nodes are behind a firewall or a NAT, seeds don't
need to make outgoing connections.</p>
<a name="no_connect_privileged_ports"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_connect_privileged_ports</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when this is true, libtorrent will not attempt to make outgoing
connections to peers whose port is &lt; 1024. This is a safety
precaution to avoid being part of a DDoS attack</p>
<a name="smooth_connects"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>smooth_connects</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">smooth_connects</tt> is true by default, which means the number of
connection attempts per second may be limited to below the
<tt class="docutils literal">connection_speed</tt>, in case we're close to bump up against the
limit of number of connections. The intention of this setting is to
more evenly distribute our connection attempts over time, instead
of attempting to connect in batches, and timing them out in
batches.</p>
<a name="always_send_user_agent"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>always_send_user_agent</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>always send user-agent in every web seed request. If false, only
the first request per http connection will include the user agent</p>
<a name="apply_ip_filter_to_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>apply_ip_filter_to_trackers</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">apply_ip_filter_to_trackers</tt> defaults to true. It determines
whether the IP filter applies to trackers as well as peers. If this
is set to false, trackers are exempt from the IP filter (if there
is one). If no IP filter is set, this setting is irrelevant.</p>
<a name="ban_web_seeds"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ban_web_seeds</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when true, web seeds sending bad data will be banned</p>
<a name="allow_partial_disk_writes"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_partial_disk_writes</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when set to false, the <tt class="docutils literal">write_cache_line_size</tt> will apply across
piece boundaries. this is a bad idea unless the piece picker also
is configured to have an affinity to pick pieces belonging to the
same write cache line as is configured in the disk cache.</p>
<a name="support_share_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>support_share_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if false, prevents libtorrent to advertise share-mode support</p>
<a name="support_merkle_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>support_merkle_torrents</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this is false, don't advertise support for the Tribler merkle
tree piece message</p>
<a name="report_redundant_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_redundant_bytes</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this is true, the number of redundant bytes is sent to the
tracker</p>
<a name="listen_system_port_fallback"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_system_port_fallback</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this is true, libtorrent will fall back to listening on a port
chosen by the operating system (i.e. binding to port 0). If a
failure is preferred, set this to false.</p>
<a name="announce_crypto_support"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_crypto_support</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when this is true, and incoming encrypted connections are enabled,
&amp;supportcrypt=1 is included in http tracker announces</p>
<a name="enable_upnp"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_upnp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the UPnP service. When started, the listen port
and the DHT port are attempted to be forwarded on local UPnP router
devices.</p>
<p>The upnp object returned by <tt class="docutils literal">start_upnp()</tt> can be used to add and
remove arbitrary port mappings. Mapping status is returned through
the <a class="reference external" href="reference-Alerts.html#portmap_alert">portmap_alert</a> and the <a class="reference external" href="reference-Alerts.html#portmap_error_alert">portmap_error_alert</a>. The object will be
valid until <tt class="docutils literal">stop_upnp()</tt> is called. See <a class="reference external" href="manual-ref.html#upnp-and-nat-pmp">upnp and nat pmp</a>.</p>
<a name="enable_natpmp"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_natpmp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the NAT-PMP service. When started, the listen port
and the DHT port are attempted to be forwarded on the router
through NAT-PMP.</p>
<p>The natpmp object returned by <tt class="docutils literal">start_natpmp()</tt> can be used to add
and remove arbitrary port mappings. Mapping status is returned
through the <a class="reference external" href="reference-Alerts.html#portmap_alert">portmap_alert</a> and the <a class="reference external" href="reference-Alerts.html#portmap_error_alert">portmap_error_alert</a>. The object
will be valid until <tt class="docutils literal">stop_natpmp()</tt> is called. See
<a class="reference external" href="manual-ref.html#upnp-and-nat-pmp">upnp and nat pmp</a>.</p>
<a name="enable_lsd"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_lsd</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops Local Service Discovery. This service will
broadcast the info-hashes of all the non-private torrents on the
local network to look for peers on the same swarm within multicast
reach.</p>
<a name="enable_dht"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_dht</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>starts the dht node and makes the trackerless service available to
torrents.</p>
<a name="prefer_rc4"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_rc4</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>if the allowed encryption level is both, setting this to true will
prefer rc4 if both methods are offered, plaintext otherwise</p>
<a name="proxy_hostnames"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_hostnames</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, hostname lookups are done via the configured proxy (if
any). This is only supported by SOCKS5 and HTTP.</p>
<a name="proxy_peer_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_peer_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, peer connections are made (and accepted) over the
configured proxy, if any. Web seeds as well as regular bittorrent
peer connections are considered &quot;peer connections&quot;. Anything
transporting actual torrent payload (trackers and DHT traffic are
not considered peer connections).</p>
<a name="auto_sequential"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_sequential</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this setting is true, torrents with a very high availability of
pieces (and seeds) are downloaded sequentially. This is more
efficient for the disk I/O. With many seeds, the download order is
unlikely to matter anyway</p>
<a name="proxy_tracker_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_tracker_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, tracker connections are made over the configured proxy, if
any.</p>
<a name="enable_ip_notifier"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_ip_notifier</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the internal IP table route changes notifier.</p>
<p>The current implementation supports multiple platforms, and it is
recommended to have it enable, but you may want to disable it if
it's supported but unreliable, or if you have a better way to
detect the changes. In the later case, you should manually call
<tt class="docutils literal"><span class="pre">session_handle::reopen_network_sockets</span></tt> to ensure network
changes are taken in consideration.</p>
<a name="dht_prefer_verified_node_ids"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_prefer_verified_node_ids</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when this is true, nodes whose IDs are derived from their source IP
according to BEP 42 (<a class="reference external" href="http://bittorrent.org/beps/bep_0042.html">http://bittorrent.org/beps/bep_0042.html</a>) are
preferred in the routing table.</p>
<a name="piece_extent_affinity"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>piece_extent_affinity</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when this is true, create an affinity for downloading 4 MiB extents
of adjecent pieces. This is an attempt to achieve better disk I/O
throughput by downloading larger extents of bytes, for torrents with
small piece sizes</p>
<a name="tracker_completion_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_completion_timeout</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_completion_timeout</tt> is the number of seconds the tracker
connection will wait from when it sent the request until it
considers the tracker to have timed-out.</p>
<a name="tracker_receive_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_receive_timeout</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_receive_timeout</tt> is the number of seconds to wait to
receive any data from the tracker. If no data is received for this
number of seconds, the tracker will be considered as having timed
out. If a tracker is down, this is the kind of timeout that will
occur.</p>
<a name="stop_tracker_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>stop_tracker_timeout</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">stop_tracker_timeout</tt> is the number of seconds to wait when
sending a stopped message before considering a tracker to have
timed out. This is usually shorter, to make the client quit faster.
If the value is set to 0, the connections to trackers with the
stopped event are suppressed.</p>
<a name="tracker_maximum_response_length"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="12%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_maximum_response_length</td>
<td>int</td>
<td>1024*1024</td>
</tr>
</tbody>
</table>
<p>this is the maximum number of bytes in a tracker response. If a
response size passes this number of bytes it will be rejected and
the connection will be closed. On gzipped responses this size is
measured on the uncompressed data. So, if you get 20 bytes of gzip
response that'll expand to 2 megabytes, it will be interrupted
before the entire response has been uncompressed (assuming the
limit is lower than 2 megs).</p>
<a name="piece_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>piece_timeout</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the number of seconds from a request is sent until it times out if
no piece response is returned.</p>
<a name="request_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>request_timeout</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>the number of seconds one block (16kB) is expected to be received
within. If it's not, the block is requested from a different peer</p>
<a name="request_queue_time"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>request_queue_time</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>the length of the request queue given in the number of seconds it
should take for the other end to send all the pieces. i.e. the
actual number of requests depends on the download rate and this
number.</p>
<a name="max_allowed_in_request_queue"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_allowed_in_request_queue</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p>the number of outstanding block requests a peer is allowed to queue
up in the client. If a peer sends more requests than this (before
the first one has been sent) the last request will be dropped. the
higher this is, the faster upload speeds the client can get to a
single peer.</p>
<a name="max_out_request_queue"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_out_request_queue</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_out_request_queue</tt> is the maximum number of outstanding
requests to send to a peer. This limit takes precedence over
<tt class="docutils literal">request_queue_time</tt>. i.e. no matter the download speed, the
number of outstanding requests will never exceed this limit.</p>
<a name="whole_pieces_threshold"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>whole_pieces_threshold</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>if a whole piece can be downloaded in this number of seconds, or
less, the peer_connection will prefer to request whole pieces at a
time from this peer. The benefit of this is to better utilize disk
caches by doing localized accesses and also to make it easier to
identify bad peers if a piece fails the hash check.</p>
<a name="peer_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="21%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_timeout</td>
<td>int</td>
<td>120</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_timeout</tt> is the number of seconds the peer connection
should wait (for any activity on the peer connection) before
closing it due to time out. This defaults to 120 seconds, since
that's what's specified in the protocol specification. After half
the time out, a keep alive message is sent.</p>
<a name="urlseed_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_timeout</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>same as peer_timeout, but only applies to url-seeds. this is
usually set lower, because web servers are expected to be more
reliable.</p>
<a name="urlseed_pipeline_size"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_pipeline_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>controls the pipelining size of url and http seeds. i.e. the number of HTTP
request to keep outstanding before waiting for the first one to
complete. It's common for web servers to limit this to a relatively
low number, like 5</p>
<a name="urlseed_wait_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_wait_retry</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>number of seconds until a new retry of a url-seed takes place.
Default retry value for http-seeds that don't provide a valid 'retry-after' header.</p>
<a name="file_pool_size"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="19%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>file_pool_size</td>
<td>int</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>sets the upper limit on the total number of files this <a class="reference external" href="reference-Core.html#session">session</a> will
keep open. The reason why files are left open at all is that some
anti virus software hooks on every file close, and scans the file
for viruses. deferring the closing of the files will be the
difference between a usable system and a completely hogged down
system. Most operating systems also has a limit on the total number
of file descriptors a process may have open.</p>
<a name="max_failcount"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_failcount</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_failcount</tt> is the maximum times we try to connect to a peer
before stop connecting again. If a peer succeeds, the failcounter
is reset. If a peer is retrieved from a peer source (other than
DHT) the failcount is decremented by one, allowing another try.</p>
<a name="min_reconnect_time"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>min_reconnect_time</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>the number of seconds to wait to reconnect to a peer. this time is
multiplied with the failcount.</p>
<a name="peer_connect_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_connect_timeout</td>
<td>int</td>
<td>15</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_connect_timeout</tt> the number of seconds to wait after a
connection attempt is initiated to a peer until it is considered as
having timed out. This setting is especially important in case the
number of half-open connections are limited, since stale half-open
connection may delay the connection of other peers considerably.</p>
<a name="connection_speed"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connection_speed</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connection_speed</tt> is the number of connection attempts that are
made per second. If a number &lt; 0 is specified, it will default to
200 connections per second. If 0 is specified, it means don't make
outgoing connections at all.</p>
<a name="inactivity_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>inactivity_timeout</td>
<td>int</td>
<td>600</td>
</tr>
</tbody>
</table>
<p>if a peer is uninteresting and uninterested for longer than this
number of seconds, it will be disconnected. default is 10 minutes</p>
<a name="unchoke_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>unchoke_interval</td>
<td>int</td>
<td>15</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">unchoke_interval</tt> is the number of seconds between
chokes/unchokes. On this interval, peers are re-evaluated for being
choked/unchoked. This is defined as 30 seconds in the protocol, and
it should be significantly longer than what it takes for TCP to
ramp up to it's max rate.</p>
<a name="optimistic_unchoke_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>optimistic_unchoke_interval</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">optimistic_unchoke_interval</tt> is the number of seconds between
each <em>optimistic</em> unchoke. On this timer, the currently
optimistically unchoked peer will change.</p>
<a name="num_want"></a><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="24%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>num_want</td>
<td>int</td>
<td>200</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">num_want</tt> is the number of peers we want from each tracker
request. It defines what is sent as the <tt class="docutils literal">&amp;num_want=</tt> parameter to
the tracker.</p>
<a name="initial_picker_threshold"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>initial_picker_threshold</td>
<td>int</td>
<td>4</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">initial_picker_threshold</tt> specifies the number of pieces we need
before we switch to rarest first picking. This defaults to 4, which
means the 4 first pieces in any torrent are picked at random, the
following pieces are picked in rarest first order.</p>
<a name="allowed_fast_set_size"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allowed_fast_set_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>the number of allowed pieces to send to peers that supports the
fast extensions</p>
<a name="suggest_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="11%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>suggest_mode</td>
<td>int</td>
<td>settings_pack::no_piece_suggestions</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">suggest_mode</tt> controls whether or not libtorrent will send out
suggest messages to create a bias of its peers to request certain
pieces. The modes are:</p>
<ul class="simple">
<li><tt class="docutils literal">no_piece_suggestions</tt> which is the default and will not send
out suggest messages.</li>
<li><tt class="docutils literal">suggest_read_cache</tt> which will send out suggest messages for
the most recent pieces that are in the read cache.</li>
</ul>
<a name="max_queued_disk_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="14%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_queued_disk_bytes</td>
<td>int</td>
<td>1024 * 1024</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_queued_disk_bytes</tt> is the maximum number of bytes, to
be written to disk, that can wait in the disk I/O thread queue.
This queue is only for waiting for the disk I/O thread to receive
the job and either write it to disk or insert it in the write
cache. When this limit is reached, the peer connections will stop
reading data from their sockets, until the disk thread catches up.
Setting this too low will severely limit your download rate.</p>
<a name="handshake_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>handshake_timeout</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>the number of seconds to wait for a handshake response from a peer.
If no response is received within this time, the peer is
disconnected.</p>
<a name="send_buffer_low_watermark"></a>
<a name="send_buffer_watermark"></a>
<a name="send_buffer_watermark_factor"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="13%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>send_buffer_low_watermark</td>
<td>int</td>
<td>10 * 1024</td>
</tr>
<tr><td>send_buffer_watermark</td>
<td>int</td>
<td>500 * 1024</td>
</tr>
<tr><td>send_buffer_watermark_factor</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">send_buffer_low_watermark</tt> the minimum send buffer target size
(send buffer includes bytes pending being read from disk). For good
and snappy seeding performance, set this fairly high, to at least
fit a few blocks. This is essentially the initial window size which
will determine how fast we can ramp up the send rate</p>
<p>if the send buffer has fewer bytes than <tt class="docutils literal">send_buffer_watermark</tt>,
we'll read another 16kB block onto it. If set too small, upload
rate capacity will suffer. If set too high, memory will be wasted.
The actual watermark may be lower than this in case the upload rate
is low, this is the upper limit.</p>
<p>the current upload rate to a peer is multiplied by this factor to
get the send buffer watermark. The factor is specified as a
percentage. i.e. 50 -&gt; 0.5 This product is clamped to the
<tt class="docutils literal">send_buffer_watermark</tt> setting to not exceed the max. For high
speed upload, this should be set to a greater value than 100. For
high capacity connections, setting this higher can improve upload
performance and disk throughput. Setting it too high may waste RAM
and create a bias towards read jobs over write jobs.</p>
<a name="choking_algorithm"></a>
<a name="seed_choking_algorithm"></a><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="9%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>choking_algorithm</td>
<td>int</td>
<td>settings_pack::fixed_slots_choker</td>
</tr>
<tr><td>seed_choking_algorithm</td>
<td>int</td>
<td>settings_pack::round_robin</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">choking_algorithm</tt> specifies which algorithm to use to determine
which peers to unchoke.</p>
<p>The options for choking algorithms are:</p>
<ul class="simple">
<li><tt class="docutils literal">fixed_slots_choker</tt> is the traditional choker with a fixed
number of unchoke slots (as specified by
<tt class="docutils literal"><span class="pre">settings_pack::unchoke_slots_limit</span></tt>).</li>
<li><tt class="docutils literal">rate_based_choker</tt> opens up unchoke slots based on the upload
rate achieved to peers. The more slots that are opened, the
marginal upload rate required to open up another slot increases.</li>
<li><tt class="docutils literal">bittyrant_choker</tt> attempts to optimize download rate by
finding the reciprocation rate of each peer individually and
prefers peers that gives the highest <em>return on investment</em>. It
still allocates all upload capacity, but shuffles it around to
the best peers first. For this choker to be efficient, you need
to set a global upload rate limit
(<tt class="docutils literal"><span class="pre">settings_pack::upload_rate_limit</span></tt>). For more information
about this choker, see the <a class="reference external" href="http://bittyrant.cs.washington.edu/#papers">paper</a>. This choker is not fully
implemented nor tested.</li>
</ul>
<p><tt class="docutils literal">seed_choking_algorithm</tt> controls the seeding unchoke behavior.
The available options are:</p>
<ul class="simple">
<li><tt class="docutils literal">round_robin</tt> which round-robins the peers that are unchoked
when seeding. This distributes the upload bandwidht uniformly and
fairly. It minimizes the ability for a peer to download everything
without redistributing it.</li>
<li><tt class="docutils literal">fastest_upload</tt> unchokes the peers we can send to the fastest.
This might be a bit more reliable in utilizing all available
capacity.</li>
<li><tt class="docutils literal">anti_leech</tt> prioritizes peers who have just started or are
just about to finish the download. The intention is to force
peers in the middle of the download to trade with each other.</li>
</ul>
<a name="cache_size"></a>
<a name="cache_expiry"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="21%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>cache_size</td>
<td>int</td>
<td>2048</td>
</tr>
<tr><td>cache_expiry</td>
<td>int</td>
<td>300</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">cache_size</tt> is the disk write and read cache. It is specified
in units of 16 KiB blocks. Buffers that are part of a peer's send
or receive buffer also count against this limit. Send and receive
buffers will never be denied to be allocated, but they will cause
the actual cached blocks to be flushed or evicted. If this is set
to -1, the cache size is automatically set based on the amount of
physical RAM on the machine. If the amount of physical RAM cannot
be determined, it's set to 1024 (= 16 MiB).</p>
<p><tt class="docutils literal">cache_expiry</tt> is the number of seconds from the last cached write
to a piece in the write cache, to when it's forcefully flushed to
disk. Default is 60 second.</p>
<p>On 32 bit builds, the effective cache size will be limited to 3/4 of
2 GiB to avoid exceeding the virtual address space limit.</p>
<a name="disk_io_write_mode"></a>
<a name="disk_io_read_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="10%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>disk_io_write_mode</td>
<td>int</td>
<td>settings_pack::enable_os_cache</td>
</tr>
<tr><td>disk_io_read_mode</td>
<td>int</td>
<td>settings_pack::enable_os_cache</td>
</tr>
</tbody>
</table>
<p>determines how files are opened when they're in read only mode
versus read and write mode. The options are:</p>
<dl class="docutils">
<dt>enable_os_cache</dt>
<dd>This is the default and files are opened normally, with the OS
caching reads and writes.</dd>
<dt>disable_os_cache</dt>
<dd>This opens all files in no-cache mode. This corresponds to the
OS not letting blocks for the files linger in the cache. This
makes sense in order to avoid the bittorrent client to
potentially evict all other processes' cache by simply handling
high throughput and large files. If libtorrent's read cache is
disabled, enabling this may reduce performance.</dd>
</dl>
<p>One reason to disable caching is that it may help the operating
system from growing its file cache indefinitely.</p>
<a name="outgoing_port"></a>
<a name="num_outgoing_ports"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>outgoing_port</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>num_outgoing_ports</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>this is the first port to use for binding outgoing connections to.
This is useful for users that have routers that allow QoS settings
based on local port. when binding outgoing connections to specific
ports, <tt class="docutils literal">num_outgoing_ports</tt> is the size of the range. It should
be more than a few</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">setting outgoing ports will limit the ability to keep
multiple connections to the same client, even for different
torrents. It is not recommended to change this setting. Its main
purpose is to use as an escape hatch for cheap routers with QoS
capability but can only classify flows based on port numbers.</p>
</div>
<p>It is a range instead of a single port because of the problems with
failing to reconnect to peers if a previous socket to that peer and
port is in <tt class="docutils literal">TIME_WAIT</tt> state.</p>
<a name="peer_tos"></a><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="24%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_tos</td>
<td>int</td>
<td>0x20</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_tos</tt> determines the TOS byte set in the IP header of every
packet sent to peers (including web seeds). The default value for
this is <tt class="docutils literal">0x0</tt> (no marking). One potentially useful TOS mark is
<tt class="docutils literal">0x20</tt>, this represents the <em>QBone scavenger service</em>. For more
details, see <a class="reference external" href="http://qbone.internet2.edu/qbss/">QBSS</a>.</p>
<a name="active_downloads"></a>
<a name="active_seeds"></a>
<a name="active_checking"></a>
<a name="active_dht_limit"></a>
<a name="active_tracker_limit"></a>
<a name="active_lsd_limit"></a>
<a name="active_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>active_downloads</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>active_seeds</td>
<td>int</td>
<td>5</td>
</tr>
<tr><td>active_checking</td>
<td>int</td>
<td>1</td>
</tr>
<tr><td>active_dht_limit</td>
<td>int</td>
<td>88</td>
</tr>
<tr><td>active_tracker_limit</td>
<td>int</td>
<td>1600</td>
</tr>
<tr><td>active_lsd_limit</td>
<td>int</td>
<td>60</td>
</tr>
<tr><td>active_limit</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p>for auto managed torrents, these are the limits they are subject
to. If there are too many torrents some of the auto managed ones
will be paused until some slots free up. <tt class="docutils literal">active_downloads</tt> and
<tt class="docutils literal">active_seeds</tt> controls how many active seeding and downloading
torrents the queuing mechanism allows. The target number of active
torrents is <tt class="docutils literal">min(active_downloads + active_seeds, active_limit)</tt>.
<tt class="docutils literal">active_downloads</tt> and <tt class="docutils literal">active_seeds</tt> are upper limits on the
number of downloading torrents and seeding torrents respectively.
Setting the value to -1 means unlimited.</p>
<p>For example if there are 10 seeding torrents and 10 downloading
torrents, and <tt class="docutils literal">active_downloads</tt> is 4 and <tt class="docutils literal">active_seeds</tt> is 4,
there will be 4 seeds active and 4 downloading torrents. If the
settings are <tt class="docutils literal">active_downloads</tt> = 2 and <tt class="docutils literal">active_seeds</tt> = 4,
then there will be 2 downloading torrents and 4 seeding torrents
active. Torrents that are not auto managed are not counted against
these limits.</p>
<p><tt class="docutils literal">active_checking</tt> is the limit of number of simultaneous checking
torrents.</p>
<p><tt class="docutils literal">active_limit</tt> is a hard limit on the number of active (auto
managed) torrents. This limit also applies to slow torrents.</p>
<p><tt class="docutils literal">active_dht_limit</tt> is the max number of torrents to announce to
the DHT. By default this is set to 88, which is no more than one
DHT announce every 10 seconds.</p>
<p><tt class="docutils literal">active_tracker_limit</tt> is the max number of torrents to announce
to their trackers. By default this is 360, which is no more than
one announce every 5 seconds.</p>
<p><tt class="docutils literal">active_lsd_limit</tt> is the max number of torrents to announce to
the local network over the local service discovery protocol. By
default this is 80, which is no more than one announce every 5
seconds (assuming the default announce interval of 5 minutes).</p>
<p>You can have more torrents <em>active</em>, even though they are not
announced to the DHT, lsd or their tracker. If some peer knows
about you for any reason and tries to connect, it will still be
accepted, unless the torrent is paused, which means it won't accept
any connections.</p>
<a name="auto_manage_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_interval</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">auto_manage_interval</tt> is the number of seconds between the
torrent queue is updated, and rotated.</p>
<a name="seed_time_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="16%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seed_time_limit</td>
<td>int</td>
<td>24 * 60 * 60</td>
</tr>
</tbody>
</table>
<p>this is the limit on the time a torrent has been an active seed
(specified in seconds) before it is considered having met the seed
limit criteria. See <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
<a name="auto_scrape_interval"></a>
<a name="auto_scrape_min_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_scrape_interval</td>
<td>int</td>
<td>1800</td>
</tr>
<tr><td>auto_scrape_min_interval</td>
<td>int</td>
<td>300</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">auto_scrape_interval</tt> is the number of seconds between scrapes
of queued torrents (auto managed and paused torrents). Auto managed
torrents that are paused, are scraped regularly in order to keep
track of their downloader/seed ratio. This ratio is used to
determine which torrents to seed and which to pause.</p>
<p><tt class="docutils literal">auto_scrape_min_interval</tt> is the minimum number of seconds
between any automatic scrape (regardless of torrent). In case there
are a large number of paused auto managed torrents, this puts a
limit on how often a scrape request is sent.</p>
<a name="max_peerlist_size"></a>
<a name="max_paused_peerlist_size"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_peerlist_size</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>max_paused_peerlist_size</td>
<td>int</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_peerlist_size</tt> is the maximum number of peers in the list of
known peers. These peers are not necessarily connected, so this
number should be much greater than the maximum number of connected
peers. Peers are evicted from the cache when the list grows passed
90% of this limit, and once the size hits the limit, peers are no
longer added to the list. If this limit is set to 0, there is no
limit on how many peers we'll keep in the peer list.</p>
<p><tt class="docutils literal">max_paused_peerlist_size</tt> is the max peer list size used for
torrents that are paused. This default to the same as
<tt class="docutils literal">max_peerlist_size</tt>, but can be used to save memory for paused
torrents, since it's not as important for them to keep a large peer
list.</p>
<a name="min_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>min_announce_interval</td>
<td>int</td>
<td>5 * 60</td>
</tr>
</tbody>
</table>
<p>this is the minimum allowed announce interval for a tracker. This
is specified in seconds and is used as a sanity check on what is
returned from a tracker. It mitigates hammering misconfigured
trackers.</p>
<a name="auto_manage_startup"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_startup</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>this is the number of seconds a torrent is considered active after
it was started, regardless of upload and download speed. This is so
that newly started torrents are not considered inactive until they
have a fair chance to start downloading.</p>
<a name="seeding_piece_quota"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seeding_piece_quota</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">seeding_piece_quota</tt> is the number of pieces to send to a peer,
when seeding, before rotating in another peer to the unchoke set.
It defaults to 3 pieces, which means that when seeding, any peer
we've sent more than this number of pieces to will be unchoked in
favour of a choked peer.</p>
<a name="max_rejects"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_rejects</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_rejects</tt> is the number of piece requests we will reject in a
row while a peer is choked before the peer is considered abusive
and is disconnected.</p>
<a name="recv_socket_buffer_size"></a>
<a name="send_socket_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>recv_socket_buffer_size</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>send_socket_buffer_size</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>specifies the buffer sizes set on peer sockets. 0 (which is the
default) means the OS default (i.e. don't change the buffer sizes).
The socket buffer sizes are changed using setsockopt() with
SOL_SOCKET/SO_RCVBUF and SO_SNDBUFFER.</p>
<a name="max_peer_recv_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="12%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_peer_recv_buffer_size</td>
<td>int</td>
<td>2 * 1024 * 1024</td>
</tr>
</tbody>
</table>
<p>the max number of bytes a single peer connection's receive buffer is
allowed to grow to.</p>
<a name="read_cache_line_size"></a>
<a name="write_cache_line_size"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>read_cache_line_size</td>
<td>int</td>
<td>32</td>
</tr>
<tr><td>write_cache_line_size</td>
<td>int</td>
<td>16</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">read_cache_line_size</tt> is the number of blocks to read into the
read cache when a read cache miss occurs. Setting this to 0 is
essentially the same thing as disabling read cache. The number of
blocks read into the read cache is always capped by the piece
boundary.</p>
<p>When a piece in the write cache has <tt class="docutils literal">write_cache_line_size</tt>
contiguous blocks in it, they will be flushed. Setting this to 1
effectively disables the write cache.</p>
<a name="optimistic_disk_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>optimistic_disk_retry</td>
<td>int</td>
<td>10 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">optimistic_disk_retry</tt> is the number of seconds from a disk
write errors occur on a torrent until libtorrent will take it out
of the upload mode, to test if the error condition has been fixed.</p>
<p>libtorrent will only do this automatically for auto managed
torrents.</p>
<p>You can explicitly take a torrent out of upload only mode using
set_upload_mode().</p>
<a name="max_suggest_pieces"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_suggest_pieces</td>
<td>int</td>
<td>16</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_suggest_pieces</tt> is the max number of suggested piece indices
received from a peer that's remembered. If a peer floods suggest
messages, this limit prevents libtorrent from using too much RAM.
It defaults to 10.</p>
<a name="local_service_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>local_service_announce_interval</td>
<td>int</td>
<td>5 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">local_service_announce_interval</tt> is the time between local
network announces for a torrent. By default, when local service
discovery is enabled a torrent announces itself every 5 minutes.
This interval is specified in seconds.</p>
<a name="dht_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_announce_interval</td>
<td>int</td>
<td>15 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">dht_announce_interval</tt> is the number of seconds between
announcing torrents to the distributed hash table (DHT).</p>
<a name="udp_tracker_token_expiry"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>udp_tracker_token_expiry</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">udp_tracker_token_expiry</tt> is the number of seconds libtorrent
will keep UDP tracker connection tokens around for. This is
specified to be 60 seconds, and defaults to that. The higher this
value is, the fewer packets have to be sent to the UDP tracker. In
order for higher values to work, the tracker needs to be configured
to match the expiration time for tokens.</p>
<a name="num_optimistic_unchoke_slots"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>num_optimistic_unchoke_slots</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">num_optimistic_unchoke_slots</tt> is the number of optimistic
unchoke slots to use. It defaults to 0, which means automatic.
Having a higher number of optimistic unchoke slots mean you will
find the good peers faster but with the trade-off to use up more
bandwidth. When this is set to 0, libtorrent opens up 20% of your
allowed upload slots as optimistic unchoke slots.</p>
<a name="default_est_reciprocation_rate"></a>
<a name="increase_est_reciprocation_rate"></a>
<a name="decrease_est_reciprocation_rate"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>default_est_reciprocation_rate</td>
<td>int</td>
<td>16000</td>
</tr>
<tr><td>increase_est_reciprocation_rate</td>
<td>int</td>
<td>20</td>
</tr>
<tr><td>decrease_est_reciprocation_rate</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">default_est_reciprocation_rate</tt> is the assumed reciprocation
rate from peers when using the BitTyrant choker. This defaults to
14 kiB/s. If set too high, you will over-estimate your peers and be
more altruistic while finding the true reciprocation rate, if it's
set too low, you'll be too stingy and waste finding the true
reciprocation rate.</p>
<p><tt class="docutils literal">increase_est_reciprocation_rate</tt> specifies how many percent the
estimated reciprocation rate should be increased by each unchoke
interval a peer is still choking us back. This defaults to 20%.
This only applies to the BitTyrant choker.</p>
<p><tt class="docutils literal">decrease_est_reciprocation_rate</tt> specifies how many percent the
estimated reciprocation rate should be decreased by each unchoke
interval a peer unchokes us. This default to 3%. This only applies
to the BitTyrant choker.</p>
<a name="max_pex_peers"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_pex_peers</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>the max number of peers we accept from pex messages from a single
peer. this limits the number of concurrent peers any of our peers
claims to be connected to. If they claim to be connected to more
than this, we'll ignore any peer that exceeds this limit</p>
<a name="tick_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tick_interval</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tick_interval</tt> specifies the number of milliseconds between
internal ticks. This is the frequency with which bandwidth quota is
distributed to peers. It should not be more than one second (i.e.
1000 ms). Setting this to a low value (around 100) means higher
resolution bandwidth quota distribution, setting it to a higher
value saves CPU cycles.</p>
<a name="share_mode_target"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>share_mode_target</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">share_mode_target</tt> specifies the target share ratio for share
mode torrents. This defaults to 3, meaning we'll try to upload 3
times as much as we download. Setting this very high, will make it
very conservative and you might end up not downloading anything
ever (and not affecting your share ratio). It does not make any
sense to set this any lower than 2. For instance, if only 3 peers
need to download the rarest piece, it's impossible to download a
single piece and upload it more than 3 times. If the
share_mode_target is set to more than 3, nothing is downloaded.</p>
<a name="upload_rate_limit"></a>
<a name="download_rate_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>upload_rate_limit</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>download_rate_limit</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">upload_rate_limit</tt> and <tt class="docutils literal">download_rate_limit</tt> sets
the session-global limits of upload and download rate limits, in
bytes per second. By default peers on the local network are not rate
limited.</p>
<p>A value of 0 means unlimited.</p>
<p>For fine grained control over rate limits, including making them apply
to local peers, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="unchoke_slots_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>unchoke_slots_limit</td>
<td>int</td>
<td>8</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">unchoke_slots_limit</tt> is the max number of unchoked peers in the
<a class="reference external" href="reference-Core.html#session">session</a>. The number of unchoke slots may be ignored depending on
what <tt class="docutils literal">choking_algorithm</tt> is set to.</p>
<a name="connections_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connections_limit</td>
<td>int</td>
<td>200</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connections_limit</tt> sets a global limit on the number of
connections opened. The number of connections is set to a hard
minimum of at least two per torrent, so if you set a too low
connections limit, and open too many torrents, the limit will not
be met.</p>
<a name="connections_slack"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connections_slack</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connections_slack</tt> is the number of incoming connections
exceeding the connection limit to accept in order to potentially
replace existing ones.</p>
<a name="utp_target_delay"></a>
<a name="utp_gain_factor"></a>
<a name="utp_min_timeout"></a>
<a name="utp_syn_resends"></a>
<a name="utp_fin_resends"></a>
<a name="utp_num_resends"></a>
<a name="utp_connect_timeout"></a>
<a name="utp_loss_multiplier"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>utp_target_delay</td>
<td>int</td>
<td>100</td>
</tr>
<tr><td>utp_gain_factor</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>utp_min_timeout</td>
<td>int</td>
<td>500</td>
</tr>
<tr><td>utp_syn_resends</td>
<td>int</td>
<td>2</td>
</tr>
<tr><td>utp_fin_resends</td>
<td>int</td>
<td>2</td>
</tr>
<tr><td>utp_num_resends</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>utp_connect_timeout</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>utp_loss_multiplier</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">utp_target_delay</tt> is the target delay for uTP sockets in
milliseconds. A high value will make uTP connections more
aggressive and cause longer queues in the upload bottleneck. It
cannot be too low, since the noise in the measurements would cause
it to send too slow. The default is 50 milliseconds.
<tt class="docutils literal">utp_gain_factor</tt> is the number of bytes the uTP congestion
window can increase at the most in one RTT. This defaults to 300
bytes. If this is set too high, the congestion controller reacts
too hard to noise and will not be stable, if it's set too low, it
will react slow to congestion and not back off as fast.</p>
<p><tt class="docutils literal">utp_min_timeout</tt> is the shortest allowed uTP socket timeout,
specified in milliseconds. This defaults to 500 milliseconds. The
timeout depends on the RTT of the connection, but is never smaller
than this value. A connection times out when every packet in a
window is lost, or when a packet is lost twice in a row (i.e. the
resent packet is lost as well).</p>
<p>The shorter the timeout is, the faster the connection will recover
from this situation, assuming the RTT is low enough.
<tt class="docutils literal">utp_syn_resends</tt> is the number of SYN packets that are sent (and
timed out) before giving up and closing the socket.
<tt class="docutils literal">utp_num_resends</tt> is the number of times a packet is sent (and
lost or timed out) before giving up and closing the connection.
<tt class="docutils literal">utp_connect_timeout</tt> is the number of milliseconds of timeout
for the initial SYN packet for uTP connections. For each timed out
packet (in a row), the timeout is doubled. <tt class="docutils literal">utp_loss_multiplier</tt>
controls how the congestion window is changed when a packet loss is
experienced. It's specified as a percentage multiplier for
<tt class="docutils literal">cwnd</tt>. By default it's set to 50 (i.e. cut in half). Do not
change this value unless you know what you're doing. Never set it
higher than 100.</p>
<a name="mixed_mode_algorithm"></a><table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="10%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>mixed_mode_algorithm</td>
<td>int</td>
<td>settings_pack::peer_proportional</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal">mixed_mode_algorithm</tt> determines how to treat TCP
connections when there are uTP connections. Since uTP is designed
to yield to TCP, there's an inherent problem when using swarms that
have both TCP and uTP connections. If nothing is done, uTP
connections would often be starved out for bandwidth by the TCP
connections. This mode is <tt class="docutils literal">prefer_tcp</tt>. The <tt class="docutils literal">peer_proportional</tt>
mode simply looks at the current throughput and rate limits all TCP
connections to their proportional share based on how many of the
connections are TCP. This works best if uTP connections are not
rate limited by the global rate limiter (which they aren't by
default).</p>
<a name="listen_queue_size"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_queue_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">listen_queue_size</tt> is the value passed in to listen() for the
listen socket. It is the number of outstanding incoming connections
to queue up while we're not actively waiting for a connection to be
accepted. The default is 5 which should be sufficient for any
normal client. If this is a high performance server which expects
to receive a lot of connections, or used in a simulator or test, it
might make sense to raise this number. It will not take affect
until the <tt class="docutils literal">listen_interfaces</tt> settings is updated.</p>
<a name="torrent_connect_boost"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>torrent_connect_boost</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">torrent_connect_boost</tt> is the number of peers to try to connect
to immediately when the first tracker response is received for a
torrent. This is a boost to given to new torrents to accelerate
them starting up. The normal connect scheduler is run once every
second, this allows peers to be connected immediately instead of
waiting for the <a class="reference external" href="reference-Core.html#session">session</a> tick to trigger connections.
This may not be set higher than 255.</p>
<a name="alert_queue_size"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>alert_queue_size</td>
<td>int</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">alert_queue_size</tt> is the maximum number of alerts queued up
internally. If alerts are not popped, the queue will eventually
fill up to this level. Once the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue is full, additional
alerts will be dropped, and not delievered to the client. Once the
client drains the queue, new alerts may be delivered again. In order
to know that alerts have been dropped, see
session_handle::dropped_alerts().</p>
<a name="max_metadata_size"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="14%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_metadata_size</td>
<td>int</td>
<td>3 * 1024 * 10240</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_metadata_size</tt> is the maximum allowed size (in bytes) to be
received by the metadata extension, i.e. magnet links.</p>
<a name="checking_mem_usage"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>checking_mem_usage</td>
<td>int</td>
<td>1024</td>
</tr>
</tbody>
</table>
<p>the number of blocks to keep outstanding at any given time when
checking torrents. Higher numbers give faster re-checks but uses
more memory. Specified in number of 16 kiB blocks</p>
<a name="predictive_piece_announce"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>predictive_piece_announce</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>if set to &gt; 0, pieces will be announced to other peers before they
are fully downloaded (and before they are hash checked). The
intention is to gain 1.5 potential round trip times per downloaded
piece. When non-zero, this indicates how many milliseconds in
advance pieces should be announced, before they are expected to be
completed.</p>
<a name="aio_threads"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>aio_threads</td>
<td>int</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>for some aio back-ends, <tt class="docutils literal">aio_threads</tt> specifies the number of
io-threads to use.</p>
<a name="tracker_backoff"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_backoff</td>
<td>int</td>
<td>250</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_backoff</tt> determines how aggressively to back off from
retrying failing trackers. This value determines <em>x</em> in the
following formula, determining the number of seconds to wait until
the next retry:</p>
<blockquote>
delay = 5 + 5 * x / 100 * fails^2</blockquote>
<p>This setting may be useful to make libtorrent more or less
aggressive in hitting trackers.</p>
<a name="share_ratio_limit"></a>
<a name="seed_time_ratio_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>share_ratio_limit</td>
<td>int</td>
<td>200</td>
</tr>
<tr><td>seed_time_ratio_limit</td>
<td>int</td>
<td>700</td>
</tr>
</tbody>
</table>
<p>when a seeding torrent reaches either the share ratio (bytes up /
bytes down) or the seed time ratio (seconds as seed / seconds as
downloader) or the seed time limit (seconds as seed) it is
considered done, and it will leave room for other torrents. These
are specified as percentages. Torrents that are considered done will
still be allowed to be seeded, they just won't have priority anymore.
For more, see <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
<a name="peer_turnover"></a>
<a name="peer_turnover_cutoff"></a>
<a name="peer_turnover_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_turnover</td>
<td>int</td>
<td>4</td>
</tr>
<tr><td>peer_turnover_cutoff</td>
<td>int</td>
<td>90</td>
</tr>
<tr><td>peer_turnover_interval</td>
<td>int</td>
<td>300</td>
</tr>
</tbody>
</table>
<p>peer_turnover is the percentage of peers to disconnect every
turnover peer_turnover_interval (if we're at the peer limit), this
is specified in percent when we are connected to more than limit *
peer_turnover_cutoff peers disconnect peer_turnover fraction of the
peers. It is specified in percent peer_turnover_interval is the
interval (in seconds) between optimistic disconnects if the
disconnects happen and how many peers are disconnected is
controlled by peer_turnover and peer_turnover_cutoff</p>
<a name="connect_seed_every_n_download"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connect_seed_every_n_download</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>this setting controls the priority of downloading torrents over
seeding or finished torrents when it comes to making peer
connections. Peer connections are throttled by the connection_speed
and the half-open connection limit. This makes peer connections a
limited resource. Torrents that still have pieces to download are
prioritized by default, to avoid having many seeding torrents use
most of the connection attempts and only give one peer every now
and then to the downloading torrent. libtorrent will loop over the
downloading torrents to connect a peer each, and every n:th
connection attempt, a finished torrent is picked to be allowed to
connect to a peer. This setting controls n.</p>
<a name="max_http_recv_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="13%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_http_recv_buffer_size</td>
<td>int</td>
<td>4*1024*204</td>
</tr>
</tbody>
</table>
<p>the max number of bytes to allow an HTTP response to be when
announcing to trackers or downloading .torrent files via the
<tt class="docutils literal">url</tt> provided in <tt class="docutils literal">add_torrent_params</tt>.</p>
<a name="max_retry_port_bind"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_retry_port_bind</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>if binding to a specific port fails, should the port be incremented
by one and tried again? This setting specifies how many times to
retry a failed port bind</p>
<a name="alert_mask"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>alert_mask</td>
<td>int</td>
<td>int</td>
</tr>
</tbody>
</table>
<p>a bitmask combining flags from alert::category_t defining which
kinds of alerts to receive</p>
<a name="out_enc_policy"></a>
<a name="in_enc_policy"></a><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="12%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>out_enc_policy</td>
<td>int</td>
<td>settings_pack::pe_enabled</td>
</tr>
<tr><td>in_enc_policy</td>
<td>int</td>
<td>settings_pack::pe_enabled</td>
</tr>
</tbody>
</table>
<p>control the settings for incoming and outgoing connections
respectively. see enc_policy enum for the available options.
Keep in mind that protocol encryption degrades performance in
several respects:</p>
<ol class="arabic simple">
<li>It prevents &quot;zero copy&quot; disk buffers being sent to peers, since
each peer needs to mutate the data (i.e. encrypt it) the data
must be copied per peer connection rather than sending the same
buffer to multiple peers.</li>
<li>The encryption itself requires more CPU than plain bittorrent
protocol. The highest cost is the Diffie Hellman exchange on
connection setup.</li>
<li>The encryption handshake adds several round-trips to the
connection setup, and delays transferring data.</li>
</ol>
<a name="allowed_enc_level"></a><table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="12%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allowed_enc_level</td>
<td>int</td>
<td>settings_pack::pe_both</td>
</tr>
</tbody>
</table>
<p>determines the encryption level of the connections. This setting
will adjust which encryption scheme is offered to the other peer,
as well as which encryption scheme is selected by the client. See
enc_level enum for options.</p>
<a name="inactive_down_rate"></a>
<a name="inactive_up_rate"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>inactive_down_rate</td>
<td>int</td>
<td>2048</td>
</tr>
<tr><td>inactive_up_rate</td>
<td>int</td>
<td>2048</td>
</tr>
</tbody>
</table>
<p>the download and upload rate limits for a torrent to be considered
active by the queuing mechanism. A torrent whose download rate is
less than <tt class="docutils literal">inactive_down_rate</tt> and whose upload rate is less than
<tt class="docutils literal">inactive_up_rate</tt> for <tt class="docutils literal">auto_manage_startup</tt> seconds, is
considered inactive, and another queued torrent may be started.
This logic is disabled if <tt class="docutils literal">dont_count_slow_torrents</tt> is false.</p>
<a name="proxy_type"></a><table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="15%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_type</td>
<td>int</td>
<td>settings_pack::none</td>
</tr>
</tbody>
</table>
<p>proxy to use, defaults to none. see proxy_type_t.</p>
<a name="proxy_port"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_port</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>the port of the proxy server</p>
<a name="i2p_port"></a><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="24%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>i2p_port</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>sets the <a class="reference external" href="http://www.i2p2.de">i2p</a> SAM bridge port to connect to. set the hostname with
the <tt class="docutils literal">i2p_hostname</tt> setting.</p>
<a name="cache_size_volatile"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>cache_size_volatile</td>
<td>int</td>
<td>256</td>
</tr>
</tbody>
</table>
<p>this determines the max number of volatile disk cache blocks. If the
number of volatile blocks exceed this limit, other volatile blocks
will start to be evicted. A disk cache block is volatile if it has
low priority, and should be one of the first blocks to be evicted
under pressure. For instance, blocks pulled into the cache as the
result of calculating a piece hash are volatile. These blocks don't
represent potential interest among peers, so the value of keeping
them in the cache is limited.</p>
<a name="urlseed_max_request_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="12%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_max_request_bytes</td>
<td>int</td>
<td>16 * 1024 * 1024</td>
</tr>
</tbody>
</table>
<p>The maximum request range of an url seed in bytes. This value
defines the largest possible sequential web seed request. Default
is 16 * 1024 * 1024. Lower values are possible but will be ignored
if they are lower then piece size.
This value should be related to your download speed to prevent
libtorrent from creating too many expensive http requests per
second. You can select a value as high as you want but keep in mind
that libtorrent can't create parallel requests if the first request
did already select the whole file.
If you combine bittorrent seeds with web seeds and pick strategies
like rarest first you may find your web seed requests split into
smaller parts because we don't download already picked pieces
twice.</p>
<a name="web_seed_name_lookup_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>web_seed_name_lookup_retry</td>
<td>int</td>
<td>1800</td>
</tr>
</tbody>
</table>
<p>time to wait until a new retry of a web seed name lookup</p>
<a name="close_file_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="13%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>close_file_interval</td>
<td>int</td>
<td>CLOSE_FILE_INTERVAL</td>
</tr>
</tbody>
</table>
<p>the number of seconds between closing the file opened the longest
ago. 0 means to disable the feature. The purpose of this is to
periodically close files to trigger the operating system flushing
disk cache. Specifically it has been observed to be required on
windows to not have the disk cache grow indefinitely.
This defaults to 120 seconds on windows, and disabled on other
systems.</p>
<a name="utp_cwnd_reduce_timer"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>utp_cwnd_reduce_timer</td>
<td>int</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>When uTP experiences packet loss, it will reduce the congestion
window, and not reduce it again for this many milliseconds, even if
experiencing another lost packet.</p>
<a name="max_web_seed_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_web_seed_connections</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>the max number of web seeds to have connected per torrent at any
given time.</p>
<a name="resolver_cache_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>resolver_cache_timeout</td>
<td>int</td>
<td>1200</td>
</tr>
</tbody>
</table>
<p>the number of seconds before the internal host name resolver
considers a cache value timed out, negative values are interpreted
as zero.</p>
<pre class="literal-block">
struct settings_pack
{
   void <strong>set_int</strong> (int name, int val);
   void <strong>set_str</strong> (int name, std::string val);
   void <strong>set_bool</strong> (int name, bool val);
   void <strong>set_int</strong> (int name, flags::bitfield_flag&lt;Type, Tag&gt; const val);
   bool <strong>has_val</strong> (int name) const;
   void <strong>clear</strong> ();
   void <strong>clear</strong> (int name);
   bool <strong>get_bool</strong> (int name) const;
   int <strong>get_int</strong> (int name) const;
   std::string const&amp; <strong>get_str</strong> (int name) const;

   enum type_bases
   {
      string_type_base,
      int_type_base,
      bool_type_base,
      type_mask,
      index_mask,
   };

   enum string_types
   {
      user_agent,
      announce_ip,
      deprecated_mmap_cache,
      handshake_client_version,
      outgoing_interfaces,
      listen_interfaces,
      proxy_hostname,
      proxy_username,
      proxy_password,
      i2p_hostname,
      peer_fingerprint,
      dht_bootstrap_nodes,
      max_string_setting_internal,
   };

   enum bool_types
   {
      allow_multiple_connections_per_ip,
      deprecated_ignore_limits_on_local_network,
      send_redundant_have,
      deprecated_lazy_bitfield,
      use_dht_as_fallback,
      upnp_ignore_nonrouters,
      use_parole_mode,
      use_read_cache,
      deprecated_use_write_cache,
      deprecated_dont_flush_write_cache,
      coalesce_reads,
      coalesce_writes,
      auto_manage_prefer_seeds,
      dont_count_slow_torrents,
      close_redundant_connections,
      prioritize_partial_pieces,
      rate_limit_ip_overhead,
      announce_to_all_tiers,
      announce_to_all_trackers,
      prefer_udp_trackers,
      strict_super_seeding,
      deprecated_lock_disk_cache,
      disable_hash_checks,
      allow_i2p_mixed,
      deprecated_low_prio_disk,
      volatile_read_cache,
      deprecated_guided_read_cache,
      no_atime_storage,
      incoming_starts_queued_torrents,
      report_true_downloaded,
      strict_end_game_mode,
      broadcast_lsd,
      enable_outgoing_utp,
      enable_incoming_utp,
      enable_outgoing_tcp,
      enable_incoming_tcp,
      no_recheck_incomplete_resume,
      anonymous_mode,
      report_web_seed_downloads,
      deprecated_rate_limit_utp,
      deprecated_announce_double_nat,
      seeding_outgoing_connections,
      no_connect_privileged_ports,
      smooth_connects,
      always_send_user_agent,
      apply_ip_filter_to_trackers,
      deprecated_use_disk_read_ahead,
      deprecated_lock_files,
      deprecated_contiguous_recv_buffer,
      ban_web_seeds,
      allow_partial_disk_writes,
      deprecated_force_proxy,
      support_share_mode,
      support_merkle_torrents,
      report_redundant_bytes,
      listen_system_port_fallback,
      deprecated_use_disk_cache_pool,
      announce_crypto_support,
      enable_upnp,
      enable_natpmp,
      enable_lsd,
      enable_dht,
      prefer_rc4,
      proxy_hostnames,
      proxy_peer_connections,
      auto_sequential,
      proxy_tracker_connections,
      enable_ip_notifier,
      dht_prefer_verified_node_ids,
      piece_extent_affinity,
      max_bool_setting_internal,
   };

   enum int_types
   {
      tracker_completion_timeout,
      tracker_receive_timeout,
      stop_tracker_timeout,
      tracker_maximum_response_length,
      piece_timeout,
      request_timeout,
      request_queue_time,
      max_allowed_in_request_queue,
      max_out_request_queue,
      whole_pieces_threshold,
      peer_timeout,
      urlseed_timeout,
      urlseed_pipeline_size,
      urlseed_wait_retry,
      file_pool_size,
      max_failcount,
      min_reconnect_time,
      peer_connect_timeout,
      connection_speed,
      inactivity_timeout,
      unchoke_interval,
      optimistic_unchoke_interval,
      num_want,
      initial_picker_threshold,
      allowed_fast_set_size,
      suggest_mode,
      max_queued_disk_bytes,
      handshake_timeout,
      send_buffer_low_watermark,
      send_buffer_watermark,
      send_buffer_watermark_factor,
      choking_algorithm,
      seed_choking_algorithm,
      cache_size,
      deprecated_cache_buffer_chunk_size,
      cache_expiry,
      disk_io_write_mode,
      disk_io_read_mode,
      outgoing_port,
      num_outgoing_ports,
      peer_tos,
      active_downloads,
      active_seeds,
      active_checking,
      active_dht_limit,
      active_tracker_limit,
      active_lsd_limit,
      active_limit,
      deprecated_active_loaded_limit,
      auto_manage_interval,
      seed_time_limit,
      auto_scrape_interval,
      auto_scrape_min_interval,
      max_peerlist_size,
      max_paused_peerlist_size,
      min_announce_interval,
      auto_manage_startup,
      seeding_piece_quota,
      max_rejects,
      recv_socket_buffer_size,
      send_socket_buffer_size,
      max_peer_recv_buffer_size,
      deprecated_file_checks_delay_per_block,
      read_cache_line_size,
      write_cache_line_size,
      optimistic_disk_retry,
      max_suggest_pieces,
      local_service_announce_interval,
      dht_announce_interval,
      udp_tracker_token_expiry,
      deprecated_default_cache_min_age,
      num_optimistic_unchoke_slots,
      default_est_reciprocation_rate,
      increase_est_reciprocation_rate,
      decrease_est_reciprocation_rate,
      max_pex_peers,
      tick_interval,
      share_mode_target,
      upload_rate_limit,
      download_rate_limit,
      deprecated_local_upload_rate_limit,
      deprecated_local_download_rate_limit,
      deprecated_dht_upload_rate_limit,
      unchoke_slots_limit,
      deprecated_half_open_limit,
      connections_limit,
      connections_slack,
      utp_target_delay,
      utp_gain_factor,
      utp_min_timeout,
      utp_syn_resends,
      utp_fin_resends,
      utp_num_resends,
      utp_connect_timeout,
      deprecated_utp_delayed_ack,
      utp_loss_multiplier,
      mixed_mode_algorithm,
      listen_queue_size,
      torrent_connect_boost,
      alert_queue_size,
      max_metadata_size,
      deprecated_hashing_threads,
      checking_mem_usage,
      predictive_piece_announce,
      aio_threads,
      deprecated_network_threads,
      deprecated_ssl_listen,
      tracker_backoff,
      share_ratio_limit,
      seed_time_ratio_limit,
      peer_turnover,
      peer_turnover_cutoff,
      peer_turnover_interval,
      connect_seed_every_n_download,
      max_http_recv_buffer_size,
      max_retry_port_bind,
      alert_mask,
      out_enc_policy,
      in_enc_policy,
      allowed_enc_level,
      inactive_down_rate,
      inactive_up_rate,
      proxy_type,
      proxy_port,
      i2p_port,
      cache_size_volatile,
      urlseed_max_request_bytes,
      web_seed_name_lookup_retry,
      close_file_interval,
      utp_cwnd_reduce_timer,
      max_web_seed_connections,
      resolver_cache_timeout,
      max_int_setting_internal,
   };

   enum settings_counts_t : std::uint8_t
   {
      num_string_settings,
      num_bool_settings,
      num_int_settings,
   };

   enum suggest_mode_t : std::uint8_t
   {
      no_piece_suggestions,
      suggest_read_cache,
   };

   enum choking_algorithm_t : std::uint8_t
   {
      fixed_slots_choker,
      rate_based_choker,
      bittyrant_choker,
   };

   enum seed_choking_algorithm_t : std::uint8_t
   {
      round_robin,
      fastest_upload,
      anti_leech,
   };

   enum io_buffer_mode_t : std::uint8_t
   {
      enable_os_cache,
      deprecated_disable_os_cache_for_aligned_files,
      disable_os_cache,
   };

   enum bandwidth_mixed_algo_t : std::uint8_t
   {
      prefer_tcp,
      peer_proportional,
   };

   enum enc_policy : std::uint8_t
   {
      pe_forced,
      pe_enabled,
      pe_disabled,
   };

   enum enc_level : std::uint8_t
   {
      pe_plaintext,
      pe_rc4,
      pe_both,
   };

   enum proxy_type_t : std::uint8_t
   {
      none,
      socks4,
      socks5,
      socks5_pw,
      http,
      http_pw,
      i2p_proxy,
   };
};
</pre>
<a name="set_str()"></a>
<a name="set_int()"></a>
<a name="set_bool()"></a><div class="section" id="set-str-set-int-set-bool">
<h3>set_str() set_int() set_bool()</h3>
<pre class="literal-block">
void <strong>set_int</strong> (int name, int val);
void <strong>set_str</strong> (int name, std::string val);
void <strong>set_bool</strong> (int name, bool val);
void <strong>set_int</strong> (int name, flags::bitfield_flag&lt;Type, Tag&gt; const val);
</pre>
<p>set a configuration option in the <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>. <tt class="docutils literal">name</tt> is one of
the enum values from <a class="reference external" href="reference-Settings.html#string_types">string_types</a>, <a class="reference external" href="reference-Settings.html#int_types">int_types</a> or <a class="reference external" href="reference-Settings.html#bool_types">bool_types</a>. They must
match the respective type of the set_* function.</p>
<a name="has_val()"></a></div>
<div class="section" id="has-val">
<h3>has_val()</h3>
<pre class="literal-block">
bool <strong>has_val</strong> (int name) const;
</pre>
<p>queries whether the specified configuration option has a value set in
this pack. <tt class="docutils literal">name</tt> can be any enumeration value from <a class="reference external" href="reference-Settings.html#string_types">string_types</a>,
<a class="reference external" href="reference-Settings.html#int_types">int_types</a> or <a class="reference external" href="reference-Settings.html#bool_types">bool_types</a>.</p>
<a name="clear()"></a></div>
<div class="section" id="clear">
<h3>clear()</h3>
<pre class="literal-block">
void <strong>clear</strong> ();
</pre>
<p>clear the settings pack from all settings</p>
<a name="clear()"></a></div>
<div class="section" id="id32">
<h3>clear()</h3>
<pre class="literal-block">
void <strong>clear</strong> (int name);
</pre>
<p>clear a specific setting from the pack</p>
<a name="get_bool()"></a>
<a name="get_str()"></a>
<a name="get_int()"></a></div>
<div class="section" id="get-bool-get-str-get-int">
<h3>get_bool() get_str() get_int()</h3>
<pre class="literal-block">
bool <strong>get_bool</strong> (int name) const;
int <strong>get_int</strong> (int name) const;
std::string const&amp; <strong>get_str</strong> (int name) const;
</pre>
<p>queries the current configuration option from the <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.
<tt class="docutils literal">name</tt> is one of the enumeration values from <a class="reference external" href="reference-Settings.html#string_types">string_types</a>, <a class="reference external" href="reference-Settings.html#int_types">int_types</a>
or <a class="reference external" href="reference-Settings.html#bool_types">bool_types</a>. The enum value must match the type of the get_*
function.</p>
<a name="type_bases"></a></div>
<div class="section" id="enum-type-bases">
<h3>enum type_bases</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="18%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>string_type_base</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>int_type_base</td>
<td>16384</td>
<td>&nbsp;</td>
</tr>
<tr><td>bool_type_base</td>
<td>32768</td>
<td>&nbsp;</td>
</tr>
<tr><td>type_mask</td>
<td>49152</td>
<td>&nbsp;</td>
</tr>
<tr><td>index_mask</td>
<td>16383</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="string_types"></a></div>
<div class="section" id="enum-string-types">
<h3>enum string_types</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="6%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>user_agent</td>
<td>&nbsp;</td>
<td>this is the client identification to the tracker. The recommended
format of this string is: &quot;ClientName/ClientVersion
libtorrent/libtorrentVersion&quot;. This name will not only be used when
making HTTP requests, but also when sending extended headers to
peers that support that extension. It may not contain r or n</td>
</tr>
<tr><td>announce_ip</td>
<td>1</td>
<td><tt class="docutils literal">announce_ip</tt> is the ip address passed along to trackers as the
<tt class="docutils literal">&amp;ip=</tt> parameter. If left as the default, that parameter is
omitted.</td>
</tr>
<tr><td>deprecated_mmap_cache</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>handshake_client_version</td>
<td>3</td>
<td>this is the client name and version identifier sent to peers in the
handshake message. If this is an empty string, the user_agent is
used instead</td>
</tr>
<tr><td>outgoing_interfaces</td>
<td>4</td>
<td>sets the network interface this <a class="reference external" href="reference-Core.html#session">session</a> will use when it opens
outgoing connections. By default, it binds outgoing connections to
INADDR_ANY and port 0 (i.e. let the OS decide). Ths parameter must
be a string containing one or more, comma separated, adapter names.
Adapter names on unix systems are of the form &quot;eth0&quot;, &quot;eth1&quot;,
&quot;tun0&quot;, etc. When specifying multiple interfaces, they will be
assigned in round-robin order. This may be useful for clients that
are multi-homed. Binding an outgoing connection to a local IP does
not necessarily make the connection via the associated NIC/Adapter.
Setting this to an empty string will disable binding of outgoing
connections.</td>
</tr>
<tr><td>listen_interfaces</td>
<td>5</td>
<td><p class="first">a comma-separated list of (IP or device name, port) pairs. These are
the listen ports that will be opened for accepting incoming uTP and
TCP connections. It is possible to listen on multiple interfaces and
multiple ports. Binding to port 0 will make the operating system
pick the port. The default is &quot;0.0.0.0:6881,[::]:6881&quot;, which binds
to all interfaces on port 6881.</p>
<p>a port that has an &quot;s&quot; suffix will accept SSL connections. (note
that SSL sockets are not enabled by default).</p>
<p>if binding fails, the <a class="reference external" href="reference-Alerts.html#listen_failed_alert">listen_failed_alert</a> is posted. If or once a
socket binding succeeds, the <a class="reference external" href="reference-Alerts.html#listen_succeeded_alert">listen_succeeded_alert</a> is posted. There
may be multiple failures before a success.</p>
<p>For example:
<tt class="docutils literal"><span class="pre">[::1]:8888</span></tt> - will only accept connections on the IPv6 loopback
address on port 8888.</p>
<p><tt class="docutils literal">eth0:4444,eth1:4444</tt> - will accept connections on port 4444 on
any IP address bound to device <tt class="docutils literal">eth0</tt> or <tt class="docutils literal">eth1</tt>.</p>
<p><tt class="docutils literal"><span class="pre">[::]:0s</span></tt> - will accept SSL connections on a port chosen by the
OS. And not accept non-SSL connections at all.</p>
<p class="last">Windows OS network adapter device name can be specified with GUID.
It can be obtained from &quot;netsh lan show interfaces&quot; command output.
GUID must be uppercased string embraced in curly brackets.
<tt class="docutils literal"><span class="pre">{E4F0B674-0DFC-48BB-98A5-2AA730BDB6D6}::7777</span></tt> - will accept
connections on port 7777 on adapter with this GUID.</p>
</td>
</tr>
<tr><td>proxy_hostname</td>
<td>6</td>
<td>when using a poxy, this is the hostname where the proxy is running
see proxy_type.</td>
</tr>
<tr><td>proxy_username</td>
<td>7</td>
<td>when using a proxy, these are the credentials (if any) to use when
connecting to it. see proxy_type</td>
</tr>
<tr><td>proxy_password</td>
<td>8</td>
<td>&nbsp;</td>
</tr>
<tr><td>i2p_hostname</td>
<td>9</td>
<td>sets the <a class="reference external" href="http://www.i2p2.de">i2p</a> SAM bridge to connect to. set the port with the
<tt class="docutils literal">i2p_port</tt> setting.</td>
</tr>
<tr><td>peer_fingerprint</td>
<td>10</td>
<td><p class="first">this is the fingerprint for the client. It will be used as the
prefix to the peer_id. If this is 20 bytes (or longer) it will be
truncated to 20 bytes and used as the entire peer-id</p>
<p class="last">There is a utility function, <a class="reference external" href="reference-Core.html#generate_fingerprint()">generate_fingerprint()</a> that can be used
to generate a standard client peer ID fingerprint prefix.</p>
</td>
</tr>
<tr><td>dht_bootstrap_nodes</td>
<td>11</td>
<td><p class="first">This is a comma-separated list of IP port-pairs. They will be added
to the DHT node (if it's enabled) as back-up nodes in case we don't
know of any. This setting will contain one or more bootstrap nodes
by default.</p>
<p class="last">Changing these after the DHT has been started may not have any
effect until the DHT is restarted.</p>
</td>
</tr>
<tr><td>max_string_setting_internal</td>
<td>12</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="bool_types"></a></div>
<div class="section" id="enum-bool-types">
<h3>enum bool_types</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="6%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_multiple_connections_per_ip</td>
<td>&nbsp;</td>
<td>determines if connections from the same IP address as existing
connections should be rejected or not. Multiple connections from
the same IP address is not allowed by default, to prevent abusive
behavior by peers. It may be useful to allow such connections in
cases where simulations are run on the same machine, and all peers
in a swarm has the same IP address.</td>
</tr>
<tr><td>deprecated_ignore_limits_on_local_network</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>send_redundant_have</td>
<td>2</td>
<td><tt class="docutils literal">send_redundant_have</tt> controls if have messages will be sent to
peers that already have the piece. This is typically not necessary,
but it might be necessary for collecting statistics in some cases.</td>
</tr>
<tr><td>deprecated_lazy_bitfield</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>use_dht_as_fallback</td>
<td>4</td>
<td><tt class="docutils literal">use_dht_as_fallback</tt> determines how the DHT is used. If this is
true, the DHT will only be used for torrents where all trackers in
its tracker list has failed. Either by an explicit error message or
a time out. This is false by default, which means the DHT is used
by default regardless of if the trackers fail or not.</td>
</tr>
<tr><td>upnp_ignore_nonrouters</td>
<td>5</td>
<td><tt class="docutils literal">upnp_ignore_nonrouters</tt> indicates whether or not the UPnP
implementation should ignore any broadcast response from a device
whose address is not the configured router for this machine. i.e.
it's a way to not talk to other people's routers by mistake.</td>
</tr>
<tr><td>use_parole_mode</td>
<td>6</td>
<td><tt class="docutils literal">use_parole_mode</tt> specifies if parole mode should be used. Parole
mode means that peers that participate in pieces that fail the hash
check are put in a mode where they are only allowed to download
whole pieces. If the whole piece a peer in parole mode fails the
hash check, it is banned. If a peer participates in a piece that
passes the hash check, it is taken out of parole mode.</td>
</tr>
<tr><td>use_read_cache</td>
<td>7</td>
<td>enable and disable caching of blocks read from disk. the purpose of
the read cache is partly read-ahead of requests but also to avoid
reading blocks back from the disk multiple times for popular
pieces.</td>
</tr>
<tr><td>deprecated_use_write_cache</td>
<td>8</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_dont_flush_write_cache</td>
<td>9</td>
<td>&nbsp;</td>
</tr>
<tr><td>coalesce_reads</td>
<td>10</td>
<td>allocate separate, contiguous, buffers for read and write calls.
Only used where writev/readv cannot be used will use more RAM but
may improve performance</td>
</tr>
<tr><td>coalesce_writes</td>
<td>11</td>
<td>&nbsp;</td>
</tr>
<tr><td>auto_manage_prefer_seeds</td>
<td>12</td>
<td>prefer seeding torrents when determining which torrents to give
active slots to, the default is false which gives preference to
downloading torrents</td>
</tr>
<tr><td>dont_count_slow_torrents</td>
<td>13</td>
<td>if <tt class="docutils literal">dont_count_slow_torrents</tt> is true, torrents without any
payload transfers are not subject to the <tt class="docutils literal">active_seeds</tt> and
<tt class="docutils literal">active_downloads</tt> limits. This is intended to make it more
likely to utilize all available bandwidth, and avoid having
torrents that don't transfer anything block the active slots.</td>
</tr>
<tr><td>close_redundant_connections</td>
<td>14</td>
<td><tt class="docutils literal">close_redundant_connections</tt> specifies whether libtorrent should
close connections where both ends have no utility in keeping the
connection open. For instance if both ends have completed their
downloads, there's no point in keeping it open.</td>
</tr>
<tr><td>prioritize_partial_pieces</td>
<td>15</td>
<td>If <tt class="docutils literal">prioritize_partial_pieces</tt> is true, partial pieces are picked
before pieces that are more rare. If false, rare pieces are always
prioritized, unless the number of partial pieces is growing out of
proportion.</td>
</tr>
<tr><td>rate_limit_ip_overhead</td>
<td>16</td>
<td>if set to true, the estimated TCP/IP overhead is drained from the
rate limiters, to avoid exceeding the limits with the total traffic</td>
</tr>
<tr><td>announce_to_all_tiers</td>
<td>17</td>
<td><p class="first"><tt class="docutils literal">announce_to_all_trackers</tt> controls how multi tracker torrents
are treated. If this is set to true, all trackers in the same tier
are announced to in parallel. If all trackers in tier 0 fails, all
trackers in tier 1 are announced as well. If it's set to false, the
behavior is as defined by the multi tracker specification. It
defaults to false, which is the same behavior previous versions of
libtorrent has had as well.</p>
<p class="last"><tt class="docutils literal">announce_to_all_tiers</tt> also controls how multi tracker torrents
are treated. When this is set to true, one tracker from each tier
is announced to. This is the uTorrent behavior. This is false by
default in order to comply with the multi-tracker specification.</p>
</td>
</tr>
<tr><td>announce_to_all_trackers</td>
<td>18</td>
<td>&nbsp;</td>
</tr>
<tr><td>prefer_udp_trackers</td>
<td>19</td>
<td><tt class="docutils literal">prefer_udp_trackers</tt> is true by default. It means that trackers
may be rearranged in a way that udp trackers are always tried
before http trackers for the same hostname. Setting this to false
means that the trackers' tier is respected and there's no
preference of one protocol over another.</td>
</tr>
<tr><td>strict_super_seeding</td>
<td>20</td>
<td><tt class="docutils literal">strict_super_seeding</tt> when this is set to true, a piece has to
have been forwarded to a third peer before another one is handed
out. This is the traditional definition of super seeding.</td>
</tr>
<tr><td>deprecated_lock_disk_cache</td>
<td>21</td>
<td>&nbsp;</td>
</tr>
<tr><td>disable_hash_checks</td>
<td>22</td>
<td>when set to true, all data downloaded from peers will be assumed to
be correct, and not tested to match the hashes in the torrent this
is only useful for simulation and testing purposes (typically
combined with disabled_storage)</td>
</tr>
<tr><td>allow_i2p_mixed</td>
<td>23</td>
<td>if this is true, i2p torrents are allowed to also get peers from
other sources than the tracker, and connect to regular IPs, not
providing any anonymization. This may be useful if the user is not
interested in the anonymization of i2p, but still wants to be able
to connect to i2p peers.</td>
</tr>
<tr><td>deprecated_low_prio_disk</td>
<td>24</td>
<td>&nbsp;</td>
</tr>
<tr><td>volatile_read_cache</td>
<td>25</td>
<td><tt class="docutils literal">volatile_read_cache</tt>, if this is set to true, read cache blocks
that are hit by peer read requests are removed from the disk cache
to free up more space. This is useful if you don't expect the disk
cache to create any cache hits from other peers than the one who
triggered the cache line to be read into the cache in the first
place.</td>
</tr>
<tr><td>deprecated_guided_read_cache</td>
<td>26</td>
<td>&nbsp;</td>
</tr>
<tr><td>no_atime_storage</td>
<td>27</td>
<td><tt class="docutils literal">no_atime_storage</tt> this is a linux-only option and passes in the
<tt class="docutils literal">O_NOATIME</tt> to <tt class="docutils literal">open()</tt> when opening files. This may lead to
some disk performance improvements.</td>
</tr>
<tr><td>incoming_starts_queued_torrents</td>
<td>28</td>
<td><tt class="docutils literal">incoming_starts_queued_torrents</tt> defaults to false. If a torrent
has been paused by the auto managed feature in libtorrent, i.e. the
torrent is paused and auto managed, this feature affects whether or
not it is automatically started on an incoming connection. The main
reason to queue torrents, is not to make them unavailable, but to
save on the overhead of announcing to the trackers, the DHT and to
avoid spreading one's unchoke slots too thin. If a peer managed to
find us, even though we're no in the torrent anymore, this setting
can make us start the torrent and serve it.</td>
</tr>
<tr><td>report_true_downloaded</td>
<td>29</td>
<td>when set to true, the downloaded counter sent to trackers will
include the actual number of payload bytes downloaded including
redundant bytes. If set to false, it will not include any redundancy
bytes</td>
</tr>
<tr><td>strict_end_game_mode</td>
<td>30</td>
<td><tt class="docutils literal">strict_end_game_mode</tt> defaults to true, and controls when a
block may be requested twice. If this is <tt class="docutils literal">true</tt>, a block may only
be requested twice when there's ay least one request to every piece
that's left to download in the torrent. This may slow down progress
on some pieces sometimes, but it may also avoid downloading a lot
of redundant bytes. If this is <tt class="docutils literal">false</tt>, libtorrent attempts to
use each peer connection to its max, by always requesting
something, even if it means requesting something that has been
requested from another peer already.</td>
</tr>
<tr><td>broadcast_lsd</td>
<td>31</td>
<td>if <tt class="docutils literal">broadcast_lsd</tt> is set to true, the local peer discovery (or
Local Service Discovery) will not only use IP multicast, but also
broadcast its messages. This can be useful when running on networks
that don't support multicast. Since broadcast messages might be
expensive and disruptive on networks, only every 8th announce uses
broadcast.</td>
</tr>
<tr><td>enable_outgoing_utp</td>
<td>32</td>
<td>when set to true, libtorrent will try to make outgoing utp
connections controls whether libtorrent will accept incoming
connections or make outgoing connections of specific type.</td>
</tr>
<tr><td>enable_incoming_utp</td>
<td>33</td>
<td>&nbsp;</td>
</tr>
<tr><td>enable_outgoing_tcp</td>
<td>34</td>
<td>&nbsp;</td>
</tr>
<tr><td>enable_incoming_tcp</td>
<td>35</td>
<td>&nbsp;</td>
</tr>
<tr><td>no_recheck_incomplete_resume</td>
<td>37</td>
<td><tt class="docutils literal">no_recheck_incomplete_resume</tt> determines if the storage should
check the whole files when resume data is incomplete or missing or
whether it should simply assume we don't have any of the data. By
default, this is determined by the existence of any of the files.
By setting this setting to true, the files won't be checked, but
will go straight to download mode.</td>
</tr>
<tr><td>anonymous_mode</td>
<td>38</td>
<td><p class="first"><tt class="docutils literal">anonymous_mode</tt> defaults to false. When set to true, the client
tries to hide its identity to a certain degree. The user-agent will be
reset to an empty string (except for private torrents). Trackers
will only be used if they are using a proxy server.
The listen sockets are closed, and incoming
connections will only be accepted through a SOCKS5 or I2P proxy (if
a peer proxy is set up and is run on the same machine as the
tracker proxy). Since no incoming connections are accepted,
NAT-PMP, UPnP, DHT and local peer discovery are all turned off when
this setting is enabled.</p>
<p class="last">If you're using I2P, it might make sense to enable anonymous mode
as well.</p>
</td>
</tr>
<tr><td>report_web_seed_downloads</td>
<td>39</td>
<td>specifies whether downloads from web seeds is reported to the
tracker or not. Defaults to on. Turning it off also excludes web
seed traffic from other stats and download rate reporting via the
libtorrent API.</td>
</tr>
<tr><td>deprecated_rate_limit_utp</td>
<td>40</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_announce_double_nat</td>
<td>41</td>
<td>&nbsp;</td>
</tr>
<tr><td>seeding_outgoing_connections</td>
<td>42</td>
<td><tt class="docutils literal">seeding_outgoing_connections</tt> determines if seeding (and
finished) torrents should attempt to make outgoing connections or
not. By default this is true. It may be set to false in very
specific applications where the cost of making outgoing connections
is high, and there are no or small benefits of doing so. For
instance, if no nodes are behind a firewall or a NAT, seeds don't
need to make outgoing connections.</td>
</tr>
<tr><td>no_connect_privileged_ports</td>
<td>43</td>
<td>when this is true, libtorrent will not attempt to make outgoing
connections to peers whose port is &lt; 1024. This is a safety
precaution to avoid being part of a DDoS attack</td>
</tr>
<tr><td>smooth_connects</td>
<td>44</td>
<td><tt class="docutils literal">smooth_connects</tt> is true by default, which means the number of
connection attempts per second may be limited to below the
<tt class="docutils literal">connection_speed</tt>, in case we're close to bump up against the
limit of number of connections. The intention of this setting is to
more evenly distribute our connection attempts over time, instead
of attempting to connect in batches, and timing them out in
batches.</td>
</tr>
<tr><td>always_send_user_agent</td>
<td>45</td>
<td>always send user-agent in every web seed request. If false, only
the first request per http connection will include the user agent</td>
</tr>
<tr><td>apply_ip_filter_to_trackers</td>
<td>46</td>
<td><tt class="docutils literal">apply_ip_filter_to_trackers</tt> defaults to true. It determines
whether the IP filter applies to trackers as well as peers. If this
is set to false, trackers are exempt from the IP filter (if there
is one). If no IP filter is set, this setting is irrelevant.</td>
</tr>
<tr><td>deprecated_use_disk_read_ahead</td>
<td>47</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_lock_files</td>
<td>48</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_contiguous_recv_buffer</td>
<td>49</td>
<td>&nbsp;</td>
</tr>
<tr><td>ban_web_seeds</td>
<td>50</td>
<td>when true, web seeds sending bad data will be banned</td>
</tr>
<tr><td>allow_partial_disk_writes</td>
<td>51</td>
<td>when set to false, the <tt class="docutils literal">write_cache_line_size</tt> will apply across
piece boundaries. this is a bad idea unless the piece picker also
is configured to have an affinity to pick pieces belonging to the
same write cache line as is configured in the disk cache.</td>
</tr>
<tr><td>deprecated_force_proxy</td>
<td>52</td>
<td>&nbsp;</td>
</tr>
<tr><td>support_share_mode</td>
<td>53</td>
<td>if false, prevents libtorrent to advertise share-mode support</td>
</tr>
<tr><td>support_merkle_torrents</td>
<td>54</td>
<td>if this is false, don't advertise support for the Tribler merkle
tree piece message</td>
</tr>
<tr><td>report_redundant_bytes</td>
<td>55</td>
<td>if this is true, the number of redundant bytes is sent to the
tracker</td>
</tr>
<tr><td>listen_system_port_fallback</td>
<td>56</td>
<td>if this is true, libtorrent will fall back to listening on a port
chosen by the operating system (i.e. binding to port 0). If a
failure is preferred, set this to false.</td>
</tr>
<tr><td>deprecated_use_disk_cache_pool</td>
<td>57</td>
<td>&nbsp;</td>
</tr>
<tr><td>announce_crypto_support</td>
<td>58</td>
<td>when this is true, and incoming encrypted connections are enabled,
&amp;supportcrypt=1 is included in http tracker announces</td>
</tr>
<tr><td>enable_upnp</td>
<td>59</td>
<td><p class="first">Starts and stops the UPnP service. When started, the listen port
and the DHT port are attempted to be forwarded on local UPnP router
devices.</p>
<p class="last">The upnp object returned by <tt class="docutils literal">start_upnp()</tt> can be used to add and
remove arbitrary port mappings. Mapping status is returned through
the <a class="reference external" href="reference-Alerts.html#portmap_alert">portmap_alert</a> and the <a class="reference external" href="reference-Alerts.html#portmap_error_alert">portmap_error_alert</a>. The object will be
valid until <tt class="docutils literal">stop_upnp()</tt> is called. See <a class="reference external" href="manual-ref.html#upnp-and-nat-pmp">upnp and nat pmp</a>.</p>
</td>
</tr>
<tr><td>enable_natpmp</td>
<td>60</td>
<td><p class="first">Starts and stops the NAT-PMP service. When started, the listen port
and the DHT port are attempted to be forwarded on the router
through NAT-PMP.</p>
<p class="last">The natpmp object returned by <tt class="docutils literal">start_natpmp()</tt> can be used to add
and remove arbitrary port mappings. Mapping status is returned
through the <a class="reference external" href="reference-Alerts.html#portmap_alert">portmap_alert</a> and the <a class="reference external" href="reference-Alerts.html#portmap_error_alert">portmap_error_alert</a>. The object
will be valid until <tt class="docutils literal">stop_natpmp()</tt> is called. See
<a class="reference external" href="manual-ref.html#upnp-and-nat-pmp">upnp and nat pmp</a>.</p>
</td>
</tr>
<tr><td>enable_lsd</td>
<td>61</td>
<td>Starts and stops Local Service Discovery. This service will
broadcast the info-hashes of all the non-private torrents on the
local network to look for peers on the same swarm within multicast
reach.</td>
</tr>
<tr><td>enable_dht</td>
<td>62</td>
<td>starts the dht node and makes the trackerless service available to
torrents.</td>
</tr>
<tr><td>prefer_rc4</td>
<td>63</td>
<td>if the allowed encryption level is both, setting this to true will
prefer rc4 if both methods are offered, plaintext otherwise</td>
</tr>
<tr><td>proxy_hostnames</td>
<td>64</td>
<td>if true, hostname lookups are done via the configured proxy (if
any). This is only supported by SOCKS5 and HTTP.</td>
</tr>
<tr><td>proxy_peer_connections</td>
<td>65</td>
<td>if true, peer connections are made (and accepted) over the
configured proxy, if any. Web seeds as well as regular bittorrent
peer connections are considered &quot;peer connections&quot;. Anything
transporting actual torrent payload (trackers and DHT traffic are
not considered peer connections).</td>
</tr>
<tr><td>auto_sequential</td>
<td>66</td>
<td>if this setting is true, torrents with a very high availability of
pieces (and seeds) are downloaded sequentially. This is more
efficient for the disk I/O. With many seeds, the download order is
unlikely to matter anyway</td>
</tr>
<tr><td>proxy_tracker_connections</td>
<td>67</td>
<td>if true, tracker connections are made over the configured proxy, if
any.</td>
</tr>
<tr><td>enable_ip_notifier</td>
<td>68</td>
<td><p class="first">Starts and stops the internal IP table route changes notifier.</p>
<p class="last">The current implementation supports multiple platforms, and it is
recommended to have it enable, but you may want to disable it if
it's supported but unreliable, or if you have a better way to
detect the changes. In the later case, you should manually call
<tt class="docutils literal"><span class="pre">session_handle::reopen_network_sockets</span></tt> to ensure network
changes are taken in consideration.</p>
</td>
</tr>
<tr><td>dht_prefer_verified_node_ids</td>
<td>69</td>
<td>when this is true, nodes whose IDs are derived from their source IP
according to BEP 42 (<a class="reference external" href="http://bittorrent.org/beps/bep_0042.html">http://bittorrent.org/beps/bep_0042.html</a>) are
preferred in the routing table.</td>
</tr>
<tr><td>piece_extent_affinity</td>
<td>70</td>
<td>when this is true, create an affinity for downloading 4 MiB extents
of adjecent pieces. This is an attempt to achieve better disk I/O
throughput by downloading larger extents of bytes, for torrents with
small piece sizes</td>
</tr>
<tr><td>max_bool_setting_internal</td>
<td>71</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="int_types"></a></div>
<div class="section" id="enum-int-types">
<h3>enum int_types</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="5%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_completion_timeout</td>
<td>&nbsp;</td>
<td><tt class="docutils literal">tracker_completion_timeout</tt> is the number of seconds the tracker
connection will wait from when it sent the request until it
considers the tracker to have timed-out.</td>
</tr>
<tr><td>tracker_receive_timeout</td>
<td>1</td>
<td><tt class="docutils literal">tracker_receive_timeout</tt> is the number of seconds to wait to
receive any data from the tracker. If no data is received for this
number of seconds, the tracker will be considered as having timed
out. If a tracker is down, this is the kind of timeout that will
occur.</td>
</tr>
<tr><td>stop_tracker_timeout</td>
<td>2</td>
<td><tt class="docutils literal">stop_tracker_timeout</tt> is the number of seconds to wait when
sending a stopped message before considering a tracker to have
timed out. This is usually shorter, to make the client quit faster.
If the value is set to 0, the connections to trackers with the
stopped event are suppressed.</td>
</tr>
<tr><td>tracker_maximum_response_length</td>
<td>3</td>
<td>this is the maximum number of bytes in a tracker response. If a
response size passes this number of bytes it will be rejected and
the connection will be closed. On gzipped responses this size is
measured on the uncompressed data. So, if you get 20 bytes of gzip
response that'll expand to 2 megabytes, it will be interrupted
before the entire response has been uncompressed (assuming the
limit is lower than 2 megs).</td>
</tr>
<tr><td>piece_timeout</td>
<td>4</td>
<td>the number of seconds from a request is sent until it times out if
no piece response is returned.</td>
</tr>
<tr><td>request_timeout</td>
<td>5</td>
<td>the number of seconds one block (16kB) is expected to be received
within. If it's not, the block is requested from a different peer</td>
</tr>
<tr><td>request_queue_time</td>
<td>6</td>
<td>the length of the request queue given in the number of seconds it
should take for the other end to send all the pieces. i.e. the
actual number of requests depends on the download rate and this
number.</td>
</tr>
<tr><td>max_allowed_in_request_queue</td>
<td>7</td>
<td>the number of outstanding block requests a peer is allowed to queue
up in the client. If a peer sends more requests than this (before
the first one has been sent) the last request will be dropped. the
higher this is, the faster upload speeds the client can get to a
single peer.</td>
</tr>
<tr><td>max_out_request_queue</td>
<td>8</td>
<td><tt class="docutils literal">max_out_request_queue</tt> is the maximum number of outstanding
requests to send to a peer. This limit takes precedence over
<tt class="docutils literal">request_queue_time</tt>. i.e. no matter the download speed, the
number of outstanding requests will never exceed this limit.</td>
</tr>
<tr><td>whole_pieces_threshold</td>
<td>9</td>
<td>if a whole piece can be downloaded in this number of seconds, or
less, the peer_connection will prefer to request whole pieces at a
time from this peer. The benefit of this is to better utilize disk
caches by doing localized accesses and also to make it easier to
identify bad peers if a piece fails the hash check.</td>
</tr>
<tr><td>peer_timeout</td>
<td>10</td>
<td><tt class="docutils literal">peer_timeout</tt> is the number of seconds the peer connection
should wait (for any activity on the peer connection) before
closing it due to time out. This defaults to 120 seconds, since
that's what's specified in the protocol specification. After half
the time out, a keep alive message is sent.</td>
</tr>
<tr><td>urlseed_timeout</td>
<td>11</td>
<td>same as peer_timeout, but only applies to url-seeds. this is
usually set lower, because web servers are expected to be more
reliable.</td>
</tr>
<tr><td>urlseed_pipeline_size</td>
<td>12</td>
<td>controls the pipelining size of url and http seeds. i.e. the number of HTTP
request to keep outstanding before waiting for the first one to
complete. It's common for web servers to limit this to a relatively
low number, like 5</td>
</tr>
<tr><td>urlseed_wait_retry</td>
<td>13</td>
<td>number of seconds until a new retry of a url-seed takes place.
Default retry value for http-seeds that don't provide a valid 'retry-after' header.</td>
</tr>
<tr><td>file_pool_size</td>
<td>14</td>
<td>sets the upper limit on the total number of files this <a class="reference external" href="reference-Core.html#session">session</a> will
keep open. The reason why files are left open at all is that some
anti virus software hooks on every file close, and scans the file
for viruses. deferring the closing of the files will be the
difference between a usable system and a completely hogged down
system. Most operating systems also has a limit on the total number
of file descriptors a process may have open.</td>
</tr>
<tr><td>max_failcount</td>
<td>15</td>
<td><tt class="docutils literal">max_failcount</tt> is the maximum times we try to connect to a peer
before stop connecting again. If a peer succeeds, the failcounter
is reset. If a peer is retrieved from a peer source (other than
DHT) the failcount is decremented by one, allowing another try.</td>
</tr>
<tr><td>min_reconnect_time</td>
<td>16</td>
<td>the number of seconds to wait to reconnect to a peer. this time is
multiplied with the failcount.</td>
</tr>
<tr><td>peer_connect_timeout</td>
<td>17</td>
<td><tt class="docutils literal">peer_connect_timeout</tt> the number of seconds to wait after a
connection attempt is initiated to a peer until it is considered as
having timed out. This setting is especially important in case the
number of half-open connections are limited, since stale half-open
connection may delay the connection of other peers considerably.</td>
</tr>
<tr><td>connection_speed</td>
<td>18</td>
<td><tt class="docutils literal">connection_speed</tt> is the number of connection attempts that are
made per second. If a number &lt; 0 is specified, it will default to
200 connections per second. If 0 is specified, it means don't make
outgoing connections at all.</td>
</tr>
<tr><td>inactivity_timeout</td>
<td>19</td>
<td>if a peer is uninteresting and uninterested for longer than this
number of seconds, it will be disconnected. default is 10 minutes</td>
</tr>
<tr><td>unchoke_interval</td>
<td>20</td>
<td><tt class="docutils literal">unchoke_interval</tt> is the number of seconds between
chokes/unchokes. On this interval, peers are re-evaluated for being
choked/unchoked. This is defined as 30 seconds in the protocol, and
it should be significantly longer than what it takes for TCP to
ramp up to it's max rate.</td>
</tr>
<tr><td>optimistic_unchoke_interval</td>
<td>21</td>
<td><tt class="docutils literal">optimistic_unchoke_interval</tt> is the number of seconds between
each <em>optimistic</em> unchoke. On this timer, the currently
optimistically unchoked peer will change.</td>
</tr>
<tr><td>num_want</td>
<td>22</td>
<td><tt class="docutils literal">num_want</tt> is the number of peers we want from each tracker
request. It defines what is sent as the <tt class="docutils literal">&amp;num_want=</tt> parameter to
the tracker.</td>
</tr>
<tr><td>initial_picker_threshold</td>
<td>23</td>
<td><tt class="docutils literal">initial_picker_threshold</tt> specifies the number of pieces we need
before we switch to rarest first picking. This defaults to 4, which
means the 4 first pieces in any torrent are picked at random, the
following pieces are picked in rarest first order.</td>
</tr>
<tr><td>allowed_fast_set_size</td>
<td>24</td>
<td>the number of allowed pieces to send to peers that supports the
fast extensions</td>
</tr>
<tr><td>suggest_mode</td>
<td>25</td>
<td><p class="first"><tt class="docutils literal">suggest_mode</tt> controls whether or not libtorrent will send out
suggest messages to create a bias of its peers to request certain
pieces. The modes are:</p>
<ul class="last simple">
<li><tt class="docutils literal">no_piece_suggestions</tt> which is the default and will not send
out suggest messages.</li>
<li><tt class="docutils literal">suggest_read_cache</tt> which will send out suggest messages for
the most recent pieces that are in the read cache.</li>
</ul>
</td>
</tr>
<tr><td>max_queued_disk_bytes</td>
<td>26</td>
<td><tt class="docutils literal">max_queued_disk_bytes</tt> is the maximum number of bytes, to
be written to disk, that can wait in the disk I/O thread queue.
This queue is only for waiting for the disk I/O thread to receive
the job and either write it to disk or insert it in the write
cache. When this limit is reached, the peer connections will stop
reading data from their sockets, until the disk thread catches up.
Setting this too low will severely limit your download rate.</td>
</tr>
<tr><td>handshake_timeout</td>
<td>27</td>
<td>the number of seconds to wait for a handshake response from a peer.
If no response is received within this time, the peer is
disconnected.</td>
</tr>
<tr><td>send_buffer_low_watermark</td>
<td>28</td>
<td><p class="first"><tt class="docutils literal">send_buffer_low_watermark</tt> the minimum send buffer target size
(send buffer includes bytes pending being read from disk). For good
and snappy seeding performance, set this fairly high, to at least
fit a few blocks. This is essentially the initial window size which
will determine how fast we can ramp up the send rate</p>
<p>if the send buffer has fewer bytes than <tt class="docutils literal">send_buffer_watermark</tt>,
we'll read another 16kB block onto it. If set too small, upload
rate capacity will suffer. If set too high, memory will be wasted.
The actual watermark may be lower than this in case the upload rate
is low, this is the upper limit.</p>
<p class="last">the current upload rate to a peer is multiplied by this factor to
get the send buffer watermark. The factor is specified as a
percentage. i.e. 50 -&gt; 0.5 This product is clamped to the
<tt class="docutils literal">send_buffer_watermark</tt> setting to not exceed the max. For high
speed upload, this should be set to a greater value than 100. For
high capacity connections, setting this higher can improve upload
performance and disk throughput. Setting it too high may waste RAM
and create a bias towards read jobs over write jobs.</p>
</td>
</tr>
<tr><td>send_buffer_watermark</td>
<td>29</td>
<td>&nbsp;</td>
</tr>
<tr><td>send_buffer_watermark_factor</td>
<td>30</td>
<td>&nbsp;</td>
</tr>
<tr><td>choking_algorithm</td>
<td>31</td>
<td><p class="first"><tt class="docutils literal">choking_algorithm</tt> specifies which algorithm to use to determine
which peers to unchoke.</p>
<p>The options for choking algorithms are:</p>
<ul class="simple">
<li><tt class="docutils literal">fixed_slots_choker</tt> is the traditional choker with a fixed
number of unchoke slots (as specified by
<tt class="docutils literal"><span class="pre">settings_pack::unchoke_slots_limit</span></tt>).</li>
<li><tt class="docutils literal">rate_based_choker</tt> opens up unchoke slots based on the upload
rate achieved to peers. The more slots that are opened, the
marginal upload rate required to open up another slot increases.</li>
<li><tt class="docutils literal">bittyrant_choker</tt> attempts to optimize download rate by
finding the reciprocation rate of each peer individually and
prefers peers that gives the highest <em>return on investment</em>. It
still allocates all upload capacity, but shuffles it around to
the best peers first. For this choker to be efficient, you need
to set a global upload rate limit
(<tt class="docutils literal"><span class="pre">settings_pack::upload_rate_limit</span></tt>). For more information
about this choker, see the <a class="reference external" href="http://bittyrant.cs.washington.edu/#papers">paper</a>. This choker is not fully
implemented nor tested.</li>
</ul>
<p><tt class="docutils literal">seed_choking_algorithm</tt> controls the seeding unchoke behavior.
The available options are:</p>
<ul class="last simple">
<li><tt class="docutils literal">round_robin</tt> which round-robins the peers that are unchoked
when seeding. This distributes the upload bandwidht uniformly and
fairly. It minimizes the ability for a peer to download everything
without redistributing it.</li>
<li><tt class="docutils literal">fastest_upload</tt> unchokes the peers we can send to the fastest.
This might be a bit more reliable in utilizing all available
capacity.</li>
<li><tt class="docutils literal">anti_leech</tt> prioritizes peers who have just started or are
just about to finish the download. The intention is to force
peers in the middle of the download to trade with each other.</li>
</ul>
</td>
</tr>
<tr><td>seed_choking_algorithm</td>
<td>32</td>
<td>&nbsp;</td>
</tr>
<tr><td>cache_size</td>
<td>33</td>
<td><p class="first"><tt class="docutils literal">cache_size</tt> is the disk write and read cache. It is specified
in units of 16 KiB blocks. Buffers that are part of a peer's send
or receive buffer also count against this limit. Send and receive
buffers will never be denied to be allocated, but they will cause
the actual cached blocks to be flushed or evicted. If this is set
to -1, the cache size is automatically set based on the amount of
physical RAM on the machine. If the amount of physical RAM cannot
be determined, it's set to 1024 (= 16 MiB).</p>
<p><tt class="docutils literal">cache_expiry</tt> is the number of seconds from the last cached write
to a piece in the write cache, to when it's forcefully flushed to
disk. Default is 60 second.</p>
<p class="last">On 32 bit builds, the effective cache size will be limited to 3/4 of
2 GiB to avoid exceeding the virtual address space limit.</p>
</td>
</tr>
<tr><td>deprecated_cache_buffer_chunk_size</td>
<td>34</td>
<td>&nbsp;</td>
</tr>
<tr><td>cache_expiry</td>
<td>35</td>
<td>&nbsp;</td>
</tr>
<tr><td>disk_io_write_mode</td>
<td>36</td>
<td><p class="first">determines how files are opened when they're in read only mode
versus read and write mode. The options are:</p>
<dl class="docutils">
<dt>enable_os_cache</dt>
<dd>This is the default and files are opened normally, with the OS
caching reads and writes.</dd>
<dt>disable_os_cache</dt>
<dd>This opens all files in no-cache mode. This corresponds to the
OS not letting blocks for the files linger in the cache. This
makes sense in order to avoid the bittorrent client to
potentially evict all other processes' cache by simply handling
high throughput and large files. If libtorrent's read cache is
disabled, enabling this may reduce performance.</dd>
</dl>
<p class="last">One reason to disable caching is that it may help the operating
system from growing its file cache indefinitely.</p>
</td>
</tr>
<tr><td>disk_io_read_mode</td>
<td>37</td>
<td>&nbsp;</td>
</tr>
<tr><td>outgoing_port</td>
<td>38</td>
<td><p class="first">this is the first port to use for binding outgoing connections to.
This is useful for users that have routers that allow QoS settings
based on local port. when binding outgoing connections to specific
ports, <tt class="docutils literal">num_outgoing_ports</tt> is the size of the range. It should
be more than a few</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">setting outgoing ports will limit the ability to keep
multiple connections to the same client, even for different
torrents. It is not recommended to change this setting. Its main
purpose is to use as an escape hatch for cheap routers with QoS
capability but can only classify flows based on port numbers.</p>
</div>
<p class="last">It is a range instead of a single port because of the problems with
failing to reconnect to peers if a previous socket to that peer and
port is in <tt class="docutils literal">TIME_WAIT</tt> state.</p>
</td>
</tr>
<tr><td>num_outgoing_ports</td>
<td>39</td>
<td>&nbsp;</td>
</tr>
<tr><td>peer_tos</td>
<td>40</td>
<td><tt class="docutils literal">peer_tos</tt> determines the TOS byte set in the IP header of every
packet sent to peers (including web seeds). The default value for
this is <tt class="docutils literal">0x0</tt> (no marking). One potentially useful TOS mark is
<tt class="docutils literal">0x20</tt>, this represents the <em>QBone scavenger service</em>. For more
details, see <a class="reference external" href="http://qbone.internet2.edu/qbss/">QBSS</a>.</td>
</tr>
<tr><td>active_downloads</td>
<td>41</td>
<td><p class="first">for auto managed torrents, these are the limits they are subject
to. If there are too many torrents some of the auto managed ones
will be paused until some slots free up. <tt class="docutils literal">active_downloads</tt> and
<tt class="docutils literal">active_seeds</tt> controls how many active seeding and downloading
torrents the queuing mechanism allows. The target number of active
torrents is <tt class="docutils literal">min(active_downloads + active_seeds, active_limit)</tt>.
<tt class="docutils literal">active_downloads</tt> and <tt class="docutils literal">active_seeds</tt> are upper limits on the
number of downloading torrents and seeding torrents respectively.
Setting the value to -1 means unlimited.</p>
<p>For example if there are 10 seeding torrents and 10 downloading
torrents, and <tt class="docutils literal">active_downloads</tt> is 4 and <tt class="docutils literal">active_seeds</tt> is 4,
there will be 4 seeds active and 4 downloading torrents. If the
settings are <tt class="docutils literal">active_downloads</tt> = 2 and <tt class="docutils literal">active_seeds</tt> = 4,
then there will be 2 downloading torrents and 4 seeding torrents
active. Torrents that are not auto managed are not counted against
these limits.</p>
<p><tt class="docutils literal">active_checking</tt> is the limit of number of simultaneous checking
torrents.</p>
<p><tt class="docutils literal">active_limit</tt> is a hard limit on the number of active (auto
managed) torrents. This limit also applies to slow torrents.</p>
<p><tt class="docutils literal">active_dht_limit</tt> is the max number of torrents to announce to
the DHT. By default this is set to 88, which is no more than one
DHT announce every 10 seconds.</p>
<p><tt class="docutils literal">active_tracker_limit</tt> is the max number of torrents to announce
to their trackers. By default this is 360, which is no more than
one announce every 5 seconds.</p>
<p><tt class="docutils literal">active_lsd_limit</tt> is the max number of torrents to announce to
the local network over the local service discovery protocol. By
default this is 80, which is no more than one announce every 5
seconds (assuming the default announce interval of 5 minutes).</p>
<p class="last">You can have more torrents <em>active</em>, even though they are not
announced to the DHT, lsd or their tracker. If some peer knows
about you for any reason and tries to connect, it will still be
accepted, unless the torrent is paused, which means it won't accept
any connections.</p>
</td>
</tr>
<tr><td>active_seeds</td>
<td>42</td>
<td>&nbsp;</td>
</tr>
<tr><td>active_checking</td>
<td>43</td>
<td>&nbsp;</td>
</tr>
<tr><td>active_dht_limit</td>
<td>44</td>
<td>&nbsp;</td>
</tr>
<tr><td>active_tracker_limit</td>
<td>45</td>
<td>&nbsp;</td>
</tr>
<tr><td>active_lsd_limit</td>
<td>46</td>
<td>&nbsp;</td>
</tr>
<tr><td>active_limit</td>
<td>47</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_active_loaded_limit</td>
<td>48</td>
<td>&nbsp;</td>
</tr>
<tr><td>auto_manage_interval</td>
<td>49</td>
<td><tt class="docutils literal">auto_manage_interval</tt> is the number of seconds between the
torrent queue is updated, and rotated.</td>
</tr>
<tr><td>seed_time_limit</td>
<td>50</td>
<td>this is the limit on the time a torrent has been an active seed
(specified in seconds) before it is considered having met the seed
limit criteria. See <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</td>
</tr>
<tr><td>auto_scrape_interval</td>
<td>51</td>
<td><p class="first"><tt class="docutils literal">auto_scrape_interval</tt> is the number of seconds between scrapes
of queued torrents (auto managed and paused torrents). Auto managed
torrents that are paused, are scraped regularly in order to keep
track of their downloader/seed ratio. This ratio is used to
determine which torrents to seed and which to pause.</p>
<p class="last"><tt class="docutils literal">auto_scrape_min_interval</tt> is the minimum number of seconds
between any automatic scrape (regardless of torrent). In case there
are a large number of paused auto managed torrents, this puts a
limit on how often a scrape request is sent.</p>
</td>
</tr>
<tr><td>auto_scrape_min_interval</td>
<td>52</td>
<td>&nbsp;</td>
</tr>
<tr><td>max_peerlist_size</td>
<td>53</td>
<td><p class="first"><tt class="docutils literal">max_peerlist_size</tt> is the maximum number of peers in the list of
known peers. These peers are not necessarily connected, so this
number should be much greater than the maximum number of connected
peers. Peers are evicted from the cache when the list grows passed
90% of this limit, and once the size hits the limit, peers are no
longer added to the list. If this limit is set to 0, there is no
limit on how many peers we'll keep in the peer list.</p>
<p class="last"><tt class="docutils literal">max_paused_peerlist_size</tt> is the max peer list size used for
torrents that are paused. This default to the same as
<tt class="docutils literal">max_peerlist_size</tt>, but can be used to save memory for paused
torrents, since it's not as important for them to keep a large peer
list.</p>
</td>
</tr>
<tr><td>max_paused_peerlist_size</td>
<td>54</td>
<td>&nbsp;</td>
</tr>
<tr><td>min_announce_interval</td>
<td>55</td>
<td>this is the minimum allowed announce interval for a tracker. This
is specified in seconds and is used as a sanity check on what is
returned from a tracker. It mitigates hammering misconfigured
trackers.</td>
</tr>
<tr><td>auto_manage_startup</td>
<td>56</td>
<td>this is the number of seconds a torrent is considered active after
it was started, regardless of upload and download speed. This is so
that newly started torrents are not considered inactive until they
have a fair chance to start downloading.</td>
</tr>
<tr><td>seeding_piece_quota</td>
<td>57</td>
<td><tt class="docutils literal">seeding_piece_quota</tt> is the number of pieces to send to a peer,
when seeding, before rotating in another peer to the unchoke set.
It defaults to 3 pieces, which means that when seeding, any peer
we've sent more than this number of pieces to will be unchoked in
favour of a choked peer.</td>
</tr>
<tr><td>max_rejects</td>
<td>58</td>
<td><tt class="docutils literal">max_rejects</tt> is the number of piece requests we will reject in a
row while a peer is choked before the peer is considered abusive
and is disconnected.</td>
</tr>
<tr><td>recv_socket_buffer_size</td>
<td>59</td>
<td>specifies the buffer sizes set on peer sockets. 0 (which is the
default) means the OS default (i.e. don't change the buffer sizes).
The socket buffer sizes are changed using setsockopt() with
SOL_SOCKET/SO_RCVBUF and SO_SNDBUFFER.</td>
</tr>
<tr><td>send_socket_buffer_size</td>
<td>60</td>
<td>&nbsp;</td>
</tr>
<tr><td>max_peer_recv_buffer_size</td>
<td>61</td>
<td>the max number of bytes a single peer connection's receive buffer is
allowed to grow to.</td>
</tr>
<tr><td>deprecated_file_checks_delay_per_block</td>
<td>62</td>
<td>&nbsp;</td>
</tr>
<tr><td>read_cache_line_size</td>
<td>63</td>
<td><p class="first"><tt class="docutils literal">read_cache_line_size</tt> is the number of blocks to read into the
read cache when a read cache miss occurs. Setting this to 0 is
essentially the same thing as disabling read cache. The number of
blocks read into the read cache is always capped by the piece
boundary.</p>
<p class="last">When a piece in the write cache has <tt class="docutils literal">write_cache_line_size</tt>
contiguous blocks in it, they will be flushed. Setting this to 1
effectively disables the write cache.</p>
</td>
</tr>
<tr><td>write_cache_line_size</td>
<td>64</td>
<td>&nbsp;</td>
</tr>
<tr><td>optimistic_disk_retry</td>
<td>65</td>
<td><p class="first"><tt class="docutils literal">optimistic_disk_retry</tt> is the number of seconds from a disk
write errors occur on a torrent until libtorrent will take it out
of the upload mode, to test if the error condition has been fixed.</p>
<p>libtorrent will only do this automatically for auto managed
torrents.</p>
<p class="last">You can explicitly take a torrent out of upload only mode using
set_upload_mode().</p>
</td>
</tr>
<tr><td>max_suggest_pieces</td>
<td>66</td>
<td><tt class="docutils literal">max_suggest_pieces</tt> is the max number of suggested piece indices
received from a peer that's remembered. If a peer floods suggest
messages, this limit prevents libtorrent from using too much RAM.
It defaults to 10.</td>
</tr>
<tr><td>local_service_announce_interval</td>
<td>67</td>
<td><tt class="docutils literal">local_service_announce_interval</tt> is the time between local
network announces for a torrent. By default, when local service
discovery is enabled a torrent announces itself every 5 minutes.
This interval is specified in seconds.</td>
</tr>
<tr><td>dht_announce_interval</td>
<td>68</td>
<td><tt class="docutils literal">dht_announce_interval</tt> is the number of seconds between
announcing torrents to the distributed hash table (DHT).</td>
</tr>
<tr><td>udp_tracker_token_expiry</td>
<td>69</td>
<td><tt class="docutils literal">udp_tracker_token_expiry</tt> is the number of seconds libtorrent
will keep UDP tracker connection tokens around for. This is
specified to be 60 seconds, and defaults to that. The higher this
value is, the fewer packets have to be sent to the UDP tracker. In
order for higher values to work, the tracker needs to be configured
to match the expiration time for tokens.</td>
</tr>
<tr><td>deprecated_default_cache_min_age</td>
<td>70</td>
<td>&nbsp;</td>
</tr>
<tr><td>num_optimistic_unchoke_slots</td>
<td>71</td>
<td><tt class="docutils literal">num_optimistic_unchoke_slots</tt> is the number of optimistic
unchoke slots to use. It defaults to 0, which means automatic.
Having a higher number of optimistic unchoke slots mean you will
find the good peers faster but with the trade-off to use up more
bandwidth. When this is set to 0, libtorrent opens up 20% of your
allowed upload slots as optimistic unchoke slots.</td>
</tr>
<tr><td>default_est_reciprocation_rate</td>
<td>72</td>
<td><p class="first"><tt class="docutils literal">default_est_reciprocation_rate</tt> is the assumed reciprocation
rate from peers when using the BitTyrant choker. This defaults to
14 kiB/s. If set too high, you will over-estimate your peers and be
more altruistic while finding the true reciprocation rate, if it's
set too low, you'll be too stingy and waste finding the true
reciprocation rate.</p>
<p><tt class="docutils literal">increase_est_reciprocation_rate</tt> specifies how many percent the
estimated reciprocation rate should be increased by each unchoke
interval a peer is still choking us back. This defaults to 20%.
This only applies to the BitTyrant choker.</p>
<p class="last"><tt class="docutils literal">decrease_est_reciprocation_rate</tt> specifies how many percent the
estimated reciprocation rate should be decreased by each unchoke
interval a peer unchokes us. This default to 3%. This only applies
to the BitTyrant choker.</p>
</td>
</tr>
<tr><td>increase_est_reciprocation_rate</td>
<td>73</td>
<td>&nbsp;</td>
</tr>
<tr><td>decrease_est_reciprocation_rate</td>
<td>74</td>
<td>&nbsp;</td>
</tr>
<tr><td>max_pex_peers</td>
<td>75</td>
<td>the max number of peers we accept from pex messages from a single
peer. this limits the number of concurrent peers any of our peers
claims to be connected to. If they claim to be connected to more
than this, we'll ignore any peer that exceeds this limit</td>
</tr>
<tr><td>tick_interval</td>
<td>76</td>
<td><tt class="docutils literal">tick_interval</tt> specifies the number of milliseconds between
internal ticks. This is the frequency with which bandwidth quota is
distributed to peers. It should not be more than one second (i.e.
1000 ms). Setting this to a low value (around 100) means higher
resolution bandwidth quota distribution, setting it to a higher
value saves CPU cycles.</td>
</tr>
<tr><td>share_mode_target</td>
<td>77</td>
<td><tt class="docutils literal">share_mode_target</tt> specifies the target share ratio for share
mode torrents. This defaults to 3, meaning we'll try to upload 3
times as much as we download. Setting this very high, will make it
very conservative and you might end up not downloading anything
ever (and not affecting your share ratio). It does not make any
sense to set this any lower than 2. For instance, if only 3 peers
need to download the rarest piece, it's impossible to download a
single piece and upload it more than 3 times. If the
share_mode_target is set to more than 3, nothing is downloaded.</td>
</tr>
<tr><td>upload_rate_limit</td>
<td>78</td>
<td><p class="first"><tt class="docutils literal">upload_rate_limit</tt> and <tt class="docutils literal">download_rate_limit</tt> sets
the session-global limits of upload and download rate limits, in
bytes per second. By default peers on the local network are not rate
limited.</p>
<p>A value of 0 means unlimited.</p>
<p class="last">For fine grained control over rate limits, including making them apply
to local peers, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
</td>
</tr>
<tr><td>download_rate_limit</td>
<td>79</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_local_upload_rate_limit</td>
<td>80</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_local_download_rate_limit</td>
<td>81</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_dht_upload_rate_limit</td>
<td>82</td>
<td>&nbsp;</td>
</tr>
<tr><td>unchoke_slots_limit</td>
<td>83</td>
<td><tt class="docutils literal">unchoke_slots_limit</tt> is the max number of unchoked peers in the
<a class="reference external" href="reference-Core.html#session">session</a>. The number of unchoke slots may be ignored depending on
what <tt class="docutils literal">choking_algorithm</tt> is set to.</td>
</tr>
<tr><td>deprecated_half_open_limit</td>
<td>84</td>
<td>&nbsp;</td>
</tr>
<tr><td>connections_limit</td>
<td>85</td>
<td><tt class="docutils literal">connections_limit</tt> sets a global limit on the number of
connections opened. The number of connections is set to a hard
minimum of at least two per torrent, so if you set a too low
connections limit, and open too many torrents, the limit will not
be met.</td>
</tr>
<tr><td>connections_slack</td>
<td>86</td>
<td><tt class="docutils literal">connections_slack</tt> is the number of incoming connections
exceeding the connection limit to accept in order to potentially
replace existing ones.</td>
</tr>
<tr><td>utp_target_delay</td>
<td>87</td>
<td><p class="first"><tt class="docutils literal">utp_target_delay</tt> is the target delay for uTP sockets in
milliseconds. A high value will make uTP connections more
aggressive and cause longer queues in the upload bottleneck. It
cannot be too low, since the noise in the measurements would cause
it to send too slow. The default is 50 milliseconds.
<tt class="docutils literal">utp_gain_factor</tt> is the number of bytes the uTP congestion
window can increase at the most in one RTT. This defaults to 300
bytes. If this is set too high, the congestion controller reacts
too hard to noise and will not be stable, if it's set too low, it
will react slow to congestion and not back off as fast.</p>
<p><tt class="docutils literal">utp_min_timeout</tt> is the shortest allowed uTP socket timeout,
specified in milliseconds. This defaults to 500 milliseconds. The
timeout depends on the RTT of the connection, but is never smaller
than this value. A connection times out when every packet in a
window is lost, or when a packet is lost twice in a row (i.e. the
resent packet is lost as well).</p>
<p class="last">The shorter the timeout is, the faster the connection will recover
from this situation, assuming the RTT is low enough.
<tt class="docutils literal">utp_syn_resends</tt> is the number of SYN packets that are sent (and
timed out) before giving up and closing the socket.
<tt class="docutils literal">utp_num_resends</tt> is the number of times a packet is sent (and
lost or timed out) before giving up and closing the connection.
<tt class="docutils literal">utp_connect_timeout</tt> is the number of milliseconds of timeout
for the initial SYN packet for uTP connections. For each timed out
packet (in a row), the timeout is doubled. <tt class="docutils literal">utp_loss_multiplier</tt>
controls how the congestion window is changed when a packet loss is
experienced. It's specified as a percentage multiplier for
<tt class="docutils literal">cwnd</tt>. By default it's set to 50 (i.e. cut in half). Do not
change this value unless you know what you're doing. Never set it
higher than 100.</p>
</td>
</tr>
<tr><td>utp_gain_factor</td>
<td>88</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp_min_timeout</td>
<td>89</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp_syn_resends</td>
<td>90</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp_fin_resends</td>
<td>91</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp_num_resends</td>
<td>92</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp_connect_timeout</td>
<td>93</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_utp_delayed_ack</td>
<td>94</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp_loss_multiplier</td>
<td>95</td>
<td>&nbsp;</td>
</tr>
<tr><td>mixed_mode_algorithm</td>
<td>96</td>
<td>The <tt class="docutils literal">mixed_mode_algorithm</tt> determines how to treat TCP
connections when there are uTP connections. Since uTP is designed
to yield to TCP, there's an inherent problem when using swarms that
have both TCP and uTP connections. If nothing is done, uTP
connections would often be starved out for bandwidth by the TCP
connections. This mode is <tt class="docutils literal">prefer_tcp</tt>. The <tt class="docutils literal">peer_proportional</tt>
mode simply looks at the current throughput and rate limits all TCP
connections to their proportional share based on how many of the
connections are TCP. This works best if uTP connections are not
rate limited by the global rate limiter (which they aren't by
default).</td>
</tr>
<tr><td>listen_queue_size</td>
<td>97</td>
<td><tt class="docutils literal">listen_queue_size</tt> is the value passed in to listen() for the
listen socket. It is the number of outstanding incoming connections
to queue up while we're not actively waiting for a connection to be
accepted. The default is 5 which should be sufficient for any
normal client. If this is a high performance server which expects
to receive a lot of connections, or used in a simulator or test, it
might make sense to raise this number. It will not take affect
until the <tt class="docutils literal">listen_interfaces</tt> settings is updated.</td>
</tr>
<tr><td>torrent_connect_boost</td>
<td>98</td>
<td><tt class="docutils literal">torrent_connect_boost</tt> is the number of peers to try to connect
to immediately when the first tracker response is received for a
torrent. This is a boost to given to new torrents to accelerate
them starting up. The normal connect scheduler is run once every
second, this allows peers to be connected immediately instead of
waiting for the <a class="reference external" href="reference-Core.html#session">session</a> tick to trigger connections.
This may not be set higher than 255.</td>
</tr>
<tr><td>alert_queue_size</td>
<td>99</td>
<td><tt class="docutils literal">alert_queue_size</tt> is the maximum number of alerts queued up
internally. If alerts are not popped, the queue will eventually
fill up to this level. Once the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue is full, additional
alerts will be dropped, and not delievered to the client. Once the
client drains the queue, new alerts may be delivered again. In order
to know that alerts have been dropped, see
session_handle::dropped_alerts().</td>
</tr>
<tr><td>max_metadata_size</td>
<td>100</td>
<td><tt class="docutils literal">max_metadata_size</tt> is the maximum allowed size (in bytes) to be
received by the metadata extension, i.e. magnet links.</td>
</tr>
<tr><td>deprecated_hashing_threads</td>
<td>101</td>
<td>&nbsp;</td>
</tr>
<tr><td>checking_mem_usage</td>
<td>102</td>
<td>the number of blocks to keep outstanding at any given time when
checking torrents. Higher numbers give faster re-checks but uses
more memory. Specified in number of 16 kiB blocks</td>
</tr>
<tr><td>predictive_piece_announce</td>
<td>103</td>
<td>if set to &gt; 0, pieces will be announced to other peers before they
are fully downloaded (and before they are hash checked). The
intention is to gain 1.5 potential round trip times per downloaded
piece. When non-zero, this indicates how many milliseconds in
advance pieces should be announced, before they are expected to be
completed.</td>
</tr>
<tr><td>aio_threads</td>
<td>104</td>
<td>for some aio back-ends, <tt class="docutils literal">aio_threads</tt> specifies the number of
io-threads to use.</td>
</tr>
<tr><td>deprecated_network_threads</td>
<td>106</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_ssl_listen</td>
<td>107</td>
<td>&nbsp;</td>
</tr>
<tr><td>tracker_backoff</td>
<td>108</td>
<td><p class="first"><tt class="docutils literal">tracker_backoff</tt> determines how aggressively to back off from
retrying failing trackers. This value determines <em>x</em> in the
following formula, determining the number of seconds to wait until
the next retry:</p>
<blockquote>
delay = 5 + 5 * x / 100 * fails^2</blockquote>
<p class="last">This setting may be useful to make libtorrent more or less
aggressive in hitting trackers.</p>
</td>
</tr>
<tr><td>share_ratio_limit</td>
<td>109</td>
<td>when a seeding torrent reaches either the share ratio (bytes up /
bytes down) or the seed time ratio (seconds as seed / seconds as
downloader) or the seed time limit (seconds as seed) it is
considered done, and it will leave room for other torrents. These
are specified as percentages. Torrents that are considered done will
still be allowed to be seeded, they just won't have priority anymore.
For more, see <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</td>
</tr>
<tr><td>seed_time_ratio_limit</td>
<td>110</td>
<td>&nbsp;</td>
</tr>
<tr><td>peer_turnover</td>
<td>111</td>
<td>peer_turnover is the percentage of peers to disconnect every
turnover peer_turnover_interval (if we're at the peer limit), this
is specified in percent when we are connected to more than limit *
peer_turnover_cutoff peers disconnect peer_turnover fraction of the
peers. It is specified in percent peer_turnover_interval is the
interval (in seconds) between optimistic disconnects if the
disconnects happen and how many peers are disconnected is
controlled by peer_turnover and peer_turnover_cutoff</td>
</tr>
<tr><td>peer_turnover_cutoff</td>
<td>112</td>
<td>&nbsp;</td>
</tr>
<tr><td>peer_turnover_interval</td>
<td>113</td>
<td>&nbsp;</td>
</tr>
<tr><td>connect_seed_every_n_download</td>
<td>114</td>
<td>this setting controls the priority of downloading torrents over
seeding or finished torrents when it comes to making peer
connections. Peer connections are throttled by the connection_speed
and the half-open connection limit. This makes peer connections a
limited resource. Torrents that still have pieces to download are
prioritized by default, to avoid having many seeding torrents use
most of the connection attempts and only give one peer every now
and then to the downloading torrent. libtorrent will loop over the
downloading torrents to connect a peer each, and every n:th
connection attempt, a finished torrent is picked to be allowed to
connect to a peer. This setting controls n.</td>
</tr>
<tr><td>max_http_recv_buffer_size</td>
<td>115</td>
<td>the max number of bytes to allow an HTTP response to be when
announcing to trackers or downloading .torrent files via the
<tt class="docutils literal">url</tt> provided in <tt class="docutils literal">add_torrent_params</tt>.</td>
</tr>
<tr><td>max_retry_port_bind</td>
<td>116</td>
<td>if binding to a specific port fails, should the port be incremented
by one and tried again? This setting specifies how many times to
retry a failed port bind</td>
</tr>
<tr><td>alert_mask</td>
<td>117</td>
<td>a bitmask combining flags from alert::category_t defining which
kinds of alerts to receive</td>
</tr>
<tr><td>out_enc_policy</td>
<td>118</td>
<td><p class="first">control the settings for incoming and outgoing connections
respectively. see enc_policy enum for the available options.
Keep in mind that protocol encryption degrades performance in
several respects:</p>
<ol class="last arabic simple">
<li>It prevents &quot;zero copy&quot; disk buffers being sent to peers, since
each peer needs to mutate the data (i.e. encrypt it) the data
must be copied per peer connection rather than sending the same
buffer to multiple peers.</li>
<li>The encryption itself requires more CPU than plain bittorrent
protocol. The highest cost is the Diffie Hellman exchange on
connection setup.</li>
<li>The encryption handshake adds several round-trips to the
connection setup, and delays transferring data.</li>
</ol>
</td>
</tr>
<tr><td>in_enc_policy</td>
<td>119</td>
<td>&nbsp;</td>
</tr>
<tr><td>allowed_enc_level</td>
<td>120</td>
<td>determines the encryption level of the connections. This setting
will adjust which encryption scheme is offered to the other peer,
as well as which encryption scheme is selected by the client. See
enc_level enum for options.</td>
</tr>
<tr><td>inactive_down_rate</td>
<td>121</td>
<td>the download and upload rate limits for a torrent to be considered
active by the queuing mechanism. A torrent whose download rate is
less than <tt class="docutils literal">inactive_down_rate</tt> and whose upload rate is less than
<tt class="docutils literal">inactive_up_rate</tt> for <tt class="docutils literal">auto_manage_startup</tt> seconds, is
considered inactive, and another queued torrent may be started.
This logic is disabled if <tt class="docutils literal">dont_count_slow_torrents</tt> is false.</td>
</tr>
<tr><td>inactive_up_rate</td>
<td>122</td>
<td>&nbsp;</td>
</tr>
<tr><td>proxy_type</td>
<td>123</td>
<td>proxy to use, defaults to none. see proxy_type_t.</td>
</tr>
<tr><td>proxy_port</td>
<td>124</td>
<td>the port of the proxy server</td>
</tr>
<tr><td>i2p_port</td>
<td>125</td>
<td>sets the <a class="reference external" href="http://www.i2p2.de">i2p</a> SAM bridge port to connect to. set the hostname with
the <tt class="docutils literal">i2p_hostname</tt> setting.</td>
</tr>
<tr><td>cache_size_volatile</td>
<td>126</td>
<td>this determines the max number of volatile disk cache blocks. If the
number of volatile blocks exceed this limit, other volatile blocks
will start to be evicted. A disk cache block is volatile if it has
low priority, and should be one of the first blocks to be evicted
under pressure. For instance, blocks pulled into the cache as the
result of calculating a piece hash are volatile. These blocks don't
represent potential interest among peers, so the value of keeping
them in the cache is limited.</td>
</tr>
<tr><td>urlseed_max_request_bytes</td>
<td>127</td>
<td>The maximum request range of an url seed in bytes. This value
defines the largest possible sequential web seed request. Default
is 16 * 1024 * 1024. Lower values are possible but will be ignored
if they are lower then piece size.
This value should be related to your download speed to prevent
libtorrent from creating too many expensive http requests per
second. You can select a value as high as you want but keep in mind
that libtorrent can't create parallel requests if the first request
did already select the whole file.
If you combine bittorrent seeds with web seeds and pick strategies
like rarest first you may find your web seed requests split into
smaller parts because we don't download already picked pieces
twice.</td>
</tr>
<tr><td>web_seed_name_lookup_retry</td>
<td>128</td>
<td>time to wait until a new retry of a web seed name lookup</td>
</tr>
<tr><td>close_file_interval</td>
<td>129</td>
<td>the number of seconds between closing the file opened the longest
ago. 0 means to disable the feature. The purpose of this is to
periodically close files to trigger the operating system flushing
disk cache. Specifically it has been observed to be required on
windows to not have the disk cache grow indefinitely.
This defaults to 120 seconds on windows, and disabled on other
systems.</td>
</tr>
<tr><td>utp_cwnd_reduce_timer</td>
<td>130</td>
<td>When uTP experiences packet loss, it will reduce the congestion
window, and not reduce it again for this many milliseconds, even if
experiencing another lost packet.</td>
</tr>
<tr><td>max_web_seed_connections</td>
<td>131</td>
<td>the max number of web seeds to have connected per torrent at any
given time.</td>
</tr>
<tr><td>resolver_cache_timeout</td>
<td>132</td>
<td>the number of seconds before the internal host name resolver
considers a cache value timed out, negative values are interpreted
as zero.</td>
</tr>
<tr><td>max_int_setting_internal</td>
<td>133</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="settings_counts_t : std::uint8_t"></a></div>
<div class="section" id="enum-settings-counts-t-std-uint8-t">
<h3>enum settings_counts_t : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="17%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>num_string_settings</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>num_bool_settings</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>num_int_settings</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="suggest_mode_t : std::uint8_t"></a></div>
<div class="section" id="enum-suggest-mode-t-std-uint8-t">
<h3>enum suggest_mode_t : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="17%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_piece_suggestions</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>suggest_read_cache</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="choking_algorithm_t : std::uint8_t"></a></div>
<div class="section" id="enum-choking-algorithm-t-std-uint8-t">
<h3>enum choking_algorithm_t : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="18%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>fixed_slots_choker</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>rate_based_choker</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>bittyrant_choker</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="seed_choking_algorithm_t : std::uint8_t"></a></div>
<div class="section" id="enum-seed-choking-algorithm-t-std-uint8-t">
<h3>enum seed_choking_algorithm_t : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="19%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>round_robin</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>fastest_upload</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>anti_leech</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="io_buffer_mode_t : std::uint8_t"></a></div>
<div class="section" id="enum-io-buffer-mode-t-std-uint8-t">
<h3>enum io_buffer_mode_t : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="10%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_os_cache</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_disable_os_cache_for_aligned_files</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>disable_os_cache</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="bandwidth_mixed_algo_t : std::uint8_t"></a></div>
<div class="section" id="enum-bandwidth-mixed-algo-t-std-uint8-t">
<h3>enum bandwidth_mixed_algo_t : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="8%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_tcp</td>
<td>0</td>
<td>disables the mixed mode bandwidth balancing</td>
</tr>
<tr><td>peer_proportional</td>
<td>1</td>
<td>does not throttle uTP, throttles TCP to the same proportion
of throughput as there are TCP connections</td>
</tr>
</tbody>
</table>
<a name="enc_policy : std::uint8_t"></a></div>
<div class="section" id="enum-enc-policy-std-uint8-t">
<h3>enum enc_policy : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="8%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pe_forced</td>
<td>0</td>
<td>Only encrypted connections are allowed. Incoming connections that
are not encrypted are closed and if the encrypted outgoing
connection fails, a non-encrypted retry will not be made.</td>
</tr>
<tr><td>pe_enabled</td>
<td>1</td>
<td>encrypted connections are enabled, but non-encrypted connections
are allowed. An incoming non-encrypted connection will be accepted,
and if an outgoing encrypted connection fails, a non- encrypted
connection will be tried.</td>
</tr>
<tr><td>pe_disabled</td>
<td>2</td>
<td>only non-encrypted connections are allowed.</td>
</tr>
</tbody>
</table>
<a name="enc_level : std::uint8_t"></a></div>
<div class="section" id="enum-enc-level-std-uint8-t">
<h3>enum enc_level : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="13%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pe_plaintext</td>
<td>1</td>
<td>use only plaintext encryption</td>
</tr>
<tr><td>pe_rc4</td>
<td>2</td>
<td>use only rc4 encryption</td>
</tr>
<tr><td>pe_both</td>
<td>3</td>
<td>allow both</td>
</tr>
</tbody>
</table>
<a name="proxy_type_t : std::uint8_t"></a></div>
<div class="section" id="enum-proxy-type-t-std-uint8-t">
<h3>enum proxy_type_t : std::uint8_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="7%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>This is the default, no proxy server is used, all other fields are
ignored.</td>
</tr>
<tr><td>socks4</td>
<td>1</td>
<td>The server is assumed to be a <a class="reference external" href="http://www.ufasoft.com/doc/socks4_protocol.htm">SOCKS4 server</a> that requires a
username.</td>
</tr>
<tr><td>socks5</td>
<td>2</td>
<td>The server is assumed to be a SOCKS5 server (<a class="reference external" href="http://www.faqs.org/rfcs/rfc1928.html">RFC 1928</a>) that does
not require any authentication. The username and password are
ignored.</td>
</tr>
<tr><td>socks5_pw</td>
<td>3</td>
<td>The server is assumed to be a SOCKS5 server that supports plain
text username and password authentication (<a class="reference external" href="http://www.faqs.org/rfcs/rfc1929.html">RFC 1929</a>). The
username and password specified may be sent to the proxy if it
requires.</td>
</tr>
<tr><td>http</td>
<td>4</td>
<td>The server is assumed to be an HTTP proxy. If the transport used
for the connection is non-HTTP, the server is assumed to support
the <a class="reference external" href="http://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01">CONNECT</a> method. i.e. for web seeds and HTTP trackers, a plain
proxy will suffice. The proxy is assumed to not require
authorization. The username and password will not be used.</td>
</tr>
<tr><td>http_pw</td>
<td>5</td>
<td>The server is assumed to be an HTTP proxy that requires user
authorization. The username and password will be sent to the proxy.</td>
</tr>
<tr><td>i2p_proxy</td>
<td>6</td>
<td>route through a i2p SAM proxy</td>
</tr>
</tbody>
</table>
<a name="min_memory_usage()"></a>
<a name="high_performance_seed()"></a></div>
</div>
<div class="section" id="min-memory-usage-high-performance-seed">
<h2>min_memory_usage() high_performance_seed()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/session.hpp">libtorrent/session.hpp</a>&quot;</p>
<pre class="literal-block">
settings_pack <strong>min_memory_usage</strong> ();
settings_pack <strong>high_performance_seed</strong> ();
</pre>
<p>The default values of the <a class="reference external" href="reference-Core.html#session">session</a> settings are set for a regular
bittorrent client running on a desktop system. There are functions that
can set the <a class="reference external" href="reference-Core.html#session">session</a> settings to pre set settings for other environments.
These can be used for the basis, and should be tweaked to fit your needs
better.</p>
<p><tt class="docutils literal">min_memory_usage</tt> returns settings that will use the minimal amount of
RAM, at the potential expense of upload and download performance. It
adjusts the socket buffer sizes, disables the disk cache, lowers the send
buffer watermarks so that each connection only has at most one block in
use at any one time. It lowers the outstanding blocks send to the disk
I/O thread so that connections only have one block waiting to be flushed
to disk at any given time. It lowers the max number of peers in the peer
list for torrents. It performs multiple smaller reads when it hashes
pieces, instead of reading it all into memory before hashing.</p>
<p>This configuration is intended to be the starting point for embedded
devices. It will significantly reduce memory usage.</p>
<p><tt class="docutils literal">high_performance_seed</tt> returns settings optimized for a seed box,
serving many peers and that doesn't do any downloading. It has a 128 MB
disk cache and has a limit of 400 files in its file pool. It support fast
upload rates by allowing large send buffers.</p>
<a name="setting_by_name()"></a>
<a name="name_for_setting()"></a></div>
<div class="section" id="setting-by-name-name-for-setting">
<h2>setting_by_name() name_for_setting()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<pre class="literal-block">
int <strong>setting_by_name</strong> (string_view name);
char const* <strong>name_for_setting</strong> (int s);
</pre>
<p>converts a setting integer (from the enums <a class="reference external" href="reference-Settings.html#string_types">string_types</a>, <a class="reference external" href="reference-Settings.html#int_types">int_types</a> or
<a class="reference external" href="reference-Settings.html#bool_types">bool_types</a>) to a string, and vice versa.</p>
<a name="default_settings()"></a></div>
<div class="section" id="default-settings">
<h2>default_settings()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<pre class="literal-block">
settings_pack <strong>default_settings</strong> ();
</pre>
<p>returns a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> with every setting set to its default value</p>
</div>
</div>

    </div>
    </div>
    <div id="gradient"></div>
    <div id="footer">
    <table>
    <tr>
      <td><a href="index.html">home</a></td>
      <td><a href="https://blog.libtorrent.org">blog</a></td>
      <td><a href="utp.html">uTP</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/libtorrent/">download</a></td>
      <td><a href="reference.html">documentation</a></td>
      <td><a href="dht_store.html">DHT put extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/py-libtorrent/">python bindings</a></td>
      <td><a href="features.html">features</a></td>
      <td><a href="dht_sec.html">DHT security extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/p/libtorrent/mailman/libtorrent-discuss/">mailing list archive</a></td>
      <td><a href="contributing.html">contributing</a></td>
      <td><a href="streaming.html">streaming</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/arvidn/libtorrent/issues">report a bug</a></td>
      <td><a href="building.html">building</a></td>
      <td><a href="bittorrent.pdf">bittorrent slides</a></td>
    </tr>
    </table>
    </div>
    <div id="filler"></div>

</div>
</body>
</html>
